@素数ダイス, カジノの種類

#DIM DYNAMIC カジノの種類

#DIM DYNAMIC LCOUNT
#DIM DYNAMIC LCOUNT2

#DIM DYNAMIC CHIP_MAX = 5;初期の持ち点
#DIM DYNAMIC CHIP_NOW, 2
#DIM DYNAMIC PRIME_NOW
#DIM DYNAMIC DIFFICULTY;難易度
#DIM DYNAMIC CHIP_VALUE;チップ1枚の価値
#DIM DYNAMIC PIP_MAX = 6;サイコロの出目の最大値
#DIM DYNAMIC WIN_MONEY
#DIM DYNAMIC TIME_REMAIN;残り時間
#DIM DYNAMIC TIME_PROCESS;経過時間
#DIM DYNAMIC TIME_START;スタート時刻
#DIM DYNAMIC PASS_FLAG
#DIM DYNAMIC DISPLAY
#DIM DYNAMIC MEMORY
#DIM DYNAMIC OPERATOR
#DIM DYNAMIC L_DIGIT, 2
#DIM DYNAMIC L_PRIME
#DIM DYNAMIC P_OV10
#DIM DYNAMIC DICE, 5

PD_RULE = 7;計算のルールを全て認めるなら7/結合を認めないなら6/結合・累乗を認めないなら5

VARSET CHIP_NOW, CHIP_MAX

$PRIME_DICE_RULE
PRINTL
PRINTL ◆素数ダイスのルール◆
PRINTFORML 4つのダイスをふって出た1～{PIP_MAX}の数字を使って
PRINTL 素数を作り出すゲームです。　例…6×6×3＋5＝113
PRINTFORML ＋－×÷と括弧\@ PD_RULE >= 6 ? と累乗 # \@が使えます。
SIF PD_RULE == 7
	PRINTL また、数字を結合させることも認められます。　例…121＋6＝127,(3×4＋1)＆1＝131
PRINTFORML 2人が同額のチップを{CHIP_MAX}枚ずつ持ってゲームをします。
PRINTL 30秒以内に「前回より大きい素数」を1つ答えてください。回答は早押しです。
PRINTL 正解するたびに相手のチップを1枚奪うことができます。(その後のゲームには使えません)
PRINTL ただし、誤答をすると相手にチップを2枚渡さなくてはなりません。
PRINTL また、両者30秒間無回答だとお互いチップを1枚失います。
PRINTL どちらかのチップがなくなるとゲーム終了です。
PRINTL なお、最初の素数の大きさは対戦相手によります。
PRINTL
PRINTL ルールの変更をしますか？
PRINTL [0]しない [1]する

BINPUT

IF RESULT == 1
	DO
		PRINTL
		PRINTL 変更する項目を選択してください。
		PRINTFORML ■使用するダイスの種類 (現在のルール:1～{PIP_MAX})
		PRINT   
		PRINTBUTTON "[0]1～6", 0
		PRINTL  [1]1～8 [2]1～9 [3]1～12 [4]1～20
		PRINT ■累乗・結合の使用 (現在のルール:
		IF PD_RULE == 5
			PRINTL どちらも使用できない)
		ELSEIF PD_RULE == 6
			PRINTL 累乗のみ使用できる)
		ELSE
			PRINTL どちらも使用できる)
		ENDIF
		PRINT   
		PRINTBUTTON "[5]どちらも使用できない", 5
		PRINTL  [6]累乗のみ使用できる [7]どちらも使用できる
		PRINTL [8]設定を終えてルールを確認する
		PRINTL [9]設定を終えてゲームを開始する
		INPUT
		SELECTCASE RESULT
			CASE 0
				PIP_MAX = 6
			CASE 1
				PIP_MAX = 8
			CASE 2
				PIP_MAX = 9
			CASE 3
				PIP_MAX = 12
			CASE 4
				PIP_MAX = 20
			CASE 5 TO 7
				PD_RULE = RESULT
			CASE 8
				GOTO PRIME_DICE_RULE
			CASE 9
				BREAK
		ENDSELECT
	LOOP 1
ENDIF

PRINTL
PRINTL 対戦相手の強さを選択してください
PRINTFORML 所持金:${MONEY}
CALL PASELIL, @"[0]最弱(賭け金:{CHIP_MAX}×2000＄ 最初の素数:1以上)"
CALL PASELIL, @"[1]弱い(賭け金:{CHIP_MAX}×5000＄ 最初の素数:10以上)"
CALL PASELIL, @"[2]普通(賭け金:{CHIP_MAX}×11000＄ 最初の素数:50以上)"
CALL PASELIL, @"[3]強い(賭け金:{CHIP_MAX}×17000＄ 最初の素数:100以上)"
SIF カジノの種類 == 2
	CALL PASELIL, @"[4]最強(賭け金:{CHIP_MAX}×570000＄ 最初の素数:1000以上)"
DO
	INPUT
	SELECTCASE RESULT
		CASE 0
			PRIME_NOW = 1;これより大きい素数を見つけなくてはならない
			DIFFICULTY = 0;難易度
			CHIP_VALUE = 2000;チップ1枚の価値
		CASE 1
			PRIME_NOW = 10
			DIFFICULTY = 1
			CHIP_VALUE = 5000
		CASE 2
			PRIME_NOW = 50
			DIFFICULTY = 2
			CHIP_VALUE = 11000
		CASE 3
			PRIME_NOW = 100
			DIFFICULTY = 3
			CHIP_VALUE = 17000
		CASE 4
			IF カジノの種類 == 2
				PRIME_NOW = 1000
				DIFFICULTY = 4
				CHIP_VALUE = 570000
			ELSE
				CONTINUE
			ENDIF
		CASEELSE
			CONTINUE
	ENDSELECT
LOOP 0

PRINTL
PRINTW ゲームを開始します。

$PRIME_DICE_START

DICE:1 = 1+RAND:(PIP_MAX)
DICE:2 = 1+RAND:(PIP_MAX)
DICE:3 = 1+RAND:(PIP_MAX)
DICE:4 = 1+RAND:(PIP_MAX)
TIME_REMAIN = (LOG(PRIME_NOW)*30000 + RAND:20000)/(1+POWER(DIFFICULTY,2));相手が回答するまでの時間
;ただし、30秒を超えると30秒に直される
;難易度3(強い)でも求める素数が22027(>exp(10)>22026)以上になると確実に30秒になる
;ちなみに22027は素数
;exp(1)=2.7 exp(2)=7.4 exp(3)=20.1 exp(4)=54.6 exp(5)=148.4
;exp(6)=403.4 exp(7)=1096.6 exp(8)=2980.96 exp(9)=8103.1 exp(10)=22026.5
SIF TIME_REMAIN > 30000
	TIME_REMAIN = 30000
PRINTL
DRAWLINE
TIME_PROCESS = 0;経過時間の記録
PASS_FLAG = 0;相手が答えるかどうか
GETMILLISECOND
TIME_START = RESULT;スタート時刻の取得
PRINTFORML チップ1枚:${CHIP_VALUE}
PRINTFORML %CALLNAME:MASTER%:{CHIP_NOW:0}枚 相手プレイヤー:{CHIP_NOW:1}枚
PRINTFORML ({DICE:1},{DICE:2},{DICE:3},{DICE:4})を全て使った{PRIME_NOW}より大きい素数は？
PRINTL [0]画面上の10キーで入力 [-1]答えない
$PRIME_DICE_INPUT
TINPUT (TIME_REMAIN-TIME_PROCESS), -1, 0
IF RESULT < -1
	GETMILLISECOND
	TIME_PROCESS += RESULT-TIME_START
	GOTO PRIME_DICE_INPUT
ELSEIF RESULT == -1
	;答えない場合、相手のターンへ
	PASS_FLAG = 1
ELSEIF RESULT == 0
	DISPLAY = 0;表示されている値
	MEMORY = 0;格納している値
	OPERATOR = 0;格納している算術記号
	$PRIME_DICE_10KEY
	GETMILLISECOND
	TIME_PROCESS = RESULT-TIME_START
	PRINTL
	PRINTFORML %CALLNAME:MASTER%:{CHIP_NOW:0}枚 相手プレイヤー:{CHIP_NOW:1}枚
	PRINTFORML ({DICE:1},{DICE:2},{DICE:3},{DICE:4})を全て使った{PRIME_NOW}より大きい素数は？
	IF OPERATOR == 1
		PRINTFORML  {MEMORY}＋
	ELSEIF OPERATOR == 2
		PRINTFORML  {MEMORY}－
	ELSEIF OPERATOR == 3
		PRINTFORML  {MEMORY}×
	ELSEIF OPERATOR == 4
		PRINTFORML  {MEMORY}÷
	ELSEIF OPERATOR == 5
		PRINTFORML  {MEMORY}＾
	ELSE
		PRINTL
	ENDIF
	PRINTFORML 【{DISPLAY}】
	PRINTBUTTON "[ AC ]", "AC"
	PRINTBUTTON "[C]", "C"
	PRINTBUTTON "[^]", "^"
	PRINTL 　◆キーボードでの入力方法◆
	PRINT [7][8][9]
	PRINTBUTTON "[/]", "/"
	PRINTL 　数字は一度に入力することができますが、
	PRINT [4][5][6]
	PRINTBUTTON "[*]", "*"
	PRINTL 　数字と記号はEnterキーで分けて入力してください。
	PRINT [1][2][3]
	PRINTBUTTON "[-]", "-"
	PRINTL 　また、"Submit"などの命令は全て大文字か全て小文字もしくは頭文字のみでも入力できます。
	PRINT [0]
	PRINTBUTTON "[ ＝ ]", "="
	PRINTBUTTON "[+]", "+"
	PRINT 　さらに、"Pass"を入力すると
	PRINTBUTTON "「答えない」", "Pass"
	PRINTL という選択ができます。
	PRINTBUTTON "[  Submit  ]", "Submit"
	PRINTL
	TINPUTS (TIME_REMAIN-TIME_PROCESS), "Pass", 0
	IF RESULTS == "0" || TOINT(RESULTS) != 0
		RESULT = TOINT(RESULTS)
		IF DISPLAY == 0
			DISPLAY = RESULT
		ELSEIF RESULT >= 0
			;表示している桁数の計算
			L_DIGIT:0 = 1 + LOG10(ABS(DISPLAY))
			;入力された桁数の計算
			IF RESULT == 0
				L_DIGIT:1 = 1
			ELSE
				L_DIGIT:1 = 1 + LOG10(RESULT)
			ENDIF
			SIF DISPLAY != 0 && L_DIGIT:0+L_DIGIT:1 < 17;答えが1京を超えるようなら入力しなおし
				DISPLAY = DISPLAY * POWER(10,L_DIGIT:1) + SIGN(DISPLAY)*RESULT
			SIF DISPLAY == 0 && L_DIGIT:0 < 17
				DISPLAY = RESULT
		ENDIF
		GOTO PRIME_DICE_10KEY
	ELSEIF RESULTS == "=" || RESULTS == "+" || RESULTS == "-" || RESULTS == "*" || RESULTS == "/" || RESULTS == "^"
		IF OPERATOR == 0
			MEMORY = DISPLAY
		ELSEIF OPERATOR == 1
			MEMORY += DISPLAY
		ELSEIF OPERATOR == 2
			MEMORY -= DISPLAY
		ELSEIF OPERATOR == 3
			SIF DISPLAY == 0 || MEMORY == 0 || (1+LOG10(ABS(DISPLAY))) + (1+LOG10(ABS(MEMORY))) < 17
				MEMORY *= DISPLAY
		ELSEIF OPERATOR == 4
			SIF DISPLAY != 0
				MEMORY /= DISPLAY
		ELSEIF OPERATOR == 5
			SIF MEMORY == 0 ||  DISPLAY*(1+LOG10(ABS(MEMORY))) < 17
				MEMORY = POWER(MEMORY,DISPLAY)
		ENDIF
		IF RESULTS != "="
			DISPLAY = 0
		ELSE
			DISPLAY = MEMORY
			MEMORY = 0
		ENDIF
		IF RESULTS == "+"
			OPERATOR = 1
		ELSEIF RESULTS == "-"
			OPERATOR = 2
		ELSEIF RESULTS == "*"
			OPERATOR = 3
		ELSEIF RESULTS == "/"
			OPERATOR = 4
		ELSEIF RESULTS == "^"
			OPERATOR = 5
		ELSE
			OPERATOR = 0
		ENDIF
		GOTO PRIME_DICE_10KEY
	ELSEIF RESULTS == "C" || RESULTS == "c"
		DISPLAY = 0
		GOTO PRIME_DICE_10KEY
	ELSEIF RESULTS == "AC" || RESULTS == "Ac" || RESULTS == "ac" || RESULTS == "A" || RESULTS == "a"
		DISPLAY = 0
		MEMORY = 0
		OPERATOR = 0
		GOTO PRIME_DICE_10KEY
	ELSEIF RESULTS == "SUBMIT" || RESULTS == "Submit" || RESULTS == "submit" || RESULTS == "S" || RESULTS == "s"
		RESULT = DISPLAY
		GOTO PRIME_DICE_JUDGE
	ELSEIF RESULTS == "PASS" || RESULTS == "Pass" || RESULTS == "pass" || RESULTS == "P" || RESULTS == "p"
		;答えない場合、相手のターンへ
		PASS_FLAG = 1
	ELSE
		PRINTL TEST
		GOTO PRIME_DICE_10KEY
	ENDIF
ELSE
	$PRIME_DICE_JUDGE
	PRINTL
	DICE = RESULT
	CALL ISCALC24, DICE, DICE:1, DICE:2, DICE:3, DICE:4
	IF RESULT
		CALL PRTFOMULA, CALC_PT, CALC_VAL:0, CALC_VAL:1, CALC_VAL:2, CALC_VAL:3
		PRINTFORM ＝{DICE}
		IF DICE > PRIME_NOW
			PRINTFORML  ＞ {PRIME_NOW}
			IF ISPRIME(DICE)
				PRINTFORML {DICE}は素数です。
				CHIP_NOW:1 -= 1
				PRIME_NOW = DICE
			ELSE
				PRINTFORML {DICE}は素数ではありません。
				CHIP_NOW:0 -= 2
			ENDIF
		ELSE
			PRINTFORML  ≦ {PRIME_NOW}
			PRINTFORML 答えは{PRIME_NOW}より大きくなければいけません。
			CHIP_NOW:0 -= 2
		ENDIF
	ELSE
		PRINTFORML 答えが{DICE}になるような計算式は見つかりませんでした。
		CHIP_NOW:0 -= 2
	ENDIF
ENDIF
;こちらが答えない場合
IF PASS_FLAG
	PRINTL
	SELECTCASE DIFFICULTY
		CASE 0
			L_PRIME = PRIME_NOW
		CASE 1
			L_PRIME = SQRT(PRIME_NOW)
		CASE 2
			L_PRIME = CBRT(PRIME_NOW)
		CASE 3
			L_PRIME = SQRT(SQRT(PRIME_NOW))
		CASE 4
			L_PRIME = SQRT(CBRT(PRIME_NOW))
	ENDSELECT
	IF !RAND:(1 + (L_PRIME/(1+DIFFICULTY)))
		;上記のRANDをクリアした場合、求める素数が10万未満なら確実に求めることができる
		P_OV10 = (PRIME_NOW+3)/10;3足して10で割って小数切り捨て
		;107, 109, 111, 113のように下一桁が7,9,1,3をひと塊とするため(この場合左の4つは11となる)
		FOR LCOUNT2, P_OV10+RAND:(1+DIFFICULTY), P_OV10+10
			FOR LCOUNT, 0, 3
				;下一桁が7,9,1,3の数のみ探索する
				DICE = LCOUNT2*10 + 7 + LCOUNT*2
				IF ISPRIME(DICE)
					CALL ISCALC24, DICE, DICE:1, DICE:2, DICE:3, DICE:4
					IF RESULT
						PRINTL 相手プレイヤーが回答します。
						CALL PRTFOMULA, CALC_PT, CALC_VAL:0, CALC_VAL:1, CALC_VAL:2, CALC_VAL:3
						PRINTFORM ＝{DICE}
						PRINTFORML  ＞ {PRIME_NOW}
						PRINTFORML {DICE}は素数です。
						PRIME_NOW = DICE
						CHIP_NOW:0 -= 1
						GOTO PRIME_DICE_TURN_END
					ENDIF
				ENDIF
			NEXT
		NEXT
		PRINTL 30秒経ちましたが、
		PRINTL 相手プレイヤーも回答しませんでした。
		CHIP_NOW:0 -= 1
		CHIP_NOW:1 -= 1
	ELSEIF RAND:(1+ L_PRIME/(CBRT(PRIME_NOW))) == 0 && TIME_REMAIN == 30000
		PRINTL 30秒経ちましたが、
		PRINTL 相手プレイヤーも回答しませんでした。
		CHIP_NOW:0 -= 1
		CHIP_NOW:1 -= 1
	ELSE
		;当てずっぽうで答える
		PRINTL 相手プレイヤーが回答します。
		DICE = ((PRIME_NOW+3)/10 + RAND:(1+DIFFICULTY))*10 + 7 + 2*RAND:4
		CALL ISCALC24, DICE, DICE:1, DICE:2, DICE:3, DICE:4
		IF RESULT
			CALL PRTFOMULA, CALC_PT, CALC_VAL:0, CALC_VAL:1, CALC_VAL:2, CALC_VAL:3
			PRINTFORM ＝{DICE}
			PRINTFORML  ＞ {PRIME_NOW}
			IF ISPRIME(DICE)
				PRINTFORML {DICE}は素数です。
				CHIP_NOW:0 -= 1
				PRIME_NOW = DICE
			ELSE
				PRINTFORML {DICE}は素数ではありません。
				CHIP_NOW:1 -= 2
			ENDIF
		ELSE
			PRINTFORML 相手プレイヤーは{DICE}と答えましたが、
			PRINTFORML 答えが{DICE}になるような計算式は見つかりませんでした。
			CHIP_NOW:1 -= 2
		ENDIF
	ENDIF
ENDIF
$PRIME_DICE_TURN_END

IF CHIP_NOW:0 <= 0 || CHIP_NOW:0 <= 0
	PRINTL
	PRINTW チップがなくなったプレイヤーがいるためゲーム終了です。
	PRINTL
	DRAWLINE
	PRINTFORML チップ開始時:{CHIP_MAX}枚
	PRINTFORML 残ったチップ:{CHIP_NOW:0}枚
	PRINTFORML 奪ったチップ:{CHIP_MAX-CHIP_NOW:1}枚
	PRINTFORML チップ総収支:\@ CHIP_NOW:0-CHIP_NOW:1 >0 ? + # \@{CHIP_NOW:0-CHIP_NOW:1}枚
	PRINTFORML チップ単価　:${CHIP_VALUE}
	WIN_MONEY = CHIP_VALUE*(CHIP_NOW:0-CHIP_NOW:1)
	IF WIN_MONEY > 0
		CALL PASELIW, @"総収支　　　:+{WIN_MONEY}＄"
		TATSUJIN++
		SAVEGLOBAL
	ELSEIF WIN_MONEY < 0
		CALL PASELIW, @"総収支　　　:{WIN_MONEY}＄"
	ELSE
		CALL PASELIW, @"総収支　　　:0＄"
	ENDIF
	MONEY += WIN_MONEY
ELSE
	PRINTL
	PRINTW 次のゲームへ進みます。
	GOTO PRIME_DICE_START
ENDIF


;ISCALCで返ってきた値「計算パターン」に対し式を出力する
;計算パターン
;★を演算子として、左から1～6もしくは7～12を対応させる
;(i):((A★B)★C)★D...10101-60606
;(ii):(A★(B★C))★D...10701-11206
;(iii):A★((B★C)★D)...70101-120101
;(iv):A★(B★(C★D))...70701-121206
;(v):(A★B)★(C★D)...111-666
@PRTFOMULA, 計算パターン, LPIP:0, LPIP:1, LPIP:2, LPIP:3
#DIM DYNAMIC 計算パターン
#DIM DYNAMIC LPIP, 4

;以下演算子(+,-,*,/,累乗,結合)を★、
;LPIP:0-LPIP:3をそれぞれA-Dとする
;※「最も内側の括弧」の記述の行に対しインデントをつけました
;(i):((A★B)★C)★D
IF INRANGE(計算パターン, 10000, 70000) && (計算パターン/100)%100 <= 6
	SETCOLOR 0x00FF00
	PRINT (
	SETCOLOR 0xFFFF00
		PRINT (
		RESETCOLOR
		PRINTFORM {LPIP:0}
		SETCOLOR 0x00FFFF
		CALL PRTOPERATOR, 計算パターン%100
		RESETCOLOR
		PRINTFORM {LPIP:1}
		SETCOLOR 0xFFFF00
		PRINT )
	CALL PRTOPERATOR, 計算パターン/100%100
	RESETCOLOR
	PRINTFORM {LPIP:2}
	SETCOLOR 0x00FF00
	PRINT )
	CALL PRTOPERATOR, 計算パターン/10000
	RESETCOLOR
	PRINTFORM {LPIP:3}
ENDIF
;(ii):(A★(B★C))★D
IF INRANGE(計算パターン, 10000, 70000) && 7 <= (計算パターン/100)%100
	SETCOLOR 0x00FF00
	PRINT (
	RESETCOLOR
	PRINTFORM {LPIP:0}
	SETCOLOR 0xFFFF00
	CALL PRTOPERATOR, 計算パターン/100%100
		PRINT (
		RESETCOLOR
		PRINTFORM {LPIP:1}
		SETCOLOR 0x00FFFF
		CALL PRTOPERATOR, 計算パターン%100
		RESETCOLOR
		PRINTFORM {LPIP:2}
		SETCOLOR 0xFFFF00
		PRINT )
	SETCOLOR 0x00FF00
	PRINT )
	CALL PRTOPERATOR, 計算パターン/10000
	RESETCOLOR
	PRINTFORM {LPIP:3}
ENDIF
;(iii):A★((B★C)★D)
IF INRANGE(計算パターン, 70000, 130000) && (計算パターン/100)%100 <= 6
	PRINTFORM {LPIP:0}
	SETCOLOR 0x00FF00
	CALL PRTOPERATOR, 計算パターン/10000
	PRINT (
	SETCOLOR 0xFFFF00
		PRINT (
		RESETCOLOR
		PRINTFORM {LPIP:1}
		SETCOLOR 0x00FFFF
		CALL PRTOPERATOR, 計算パターン%100
		RESETCOLOR
		PRINTFORM {LPIP:2}
		SETCOLOR 0xFFFF00
		PRINT )
	CALL PRTOPERATOR, 計算パターン/100%100
	RESETCOLOR
	PRINTFORM {LPIP:3}
	SETCOLOR 0x00FF00
	PRINT )
	RESETCOLOR
ENDIF
;(iv):A★(B★(C★D))
IF INRANGE(計算パターン, 70000, 130000) && 7 <= (計算パターン/100)%100
	PRINTFORM {LPIP:0}
	SETCOLOR 0x00FF00
	CALL PRTOPERATOR, 計算パターン/10000
	PRINT (
	RESETCOLOR
	PRINTFORM {LPIP:1}
	SETCOLOR 0xFFFF00
	CALL PRTOPERATOR, 計算パターン/100%100
		PRINT (
		RESETCOLOR
		PRINTFORM {LPIP:2}
		SETCOLOR 0x00FFFF
		CALL PRTOPERATOR, 計算パターン%100
		RESETCOLOR
		PRINTFORM {LPIP:3}
		SETCOLOR 0xFFFF00
		PRINT )
	SETCOLOR 0x00FF00
	PRINT )
	RESETCOLOR
ENDIF
;(v):(A★B)★(C★D)
IF INRANGE(計算パターン, 100, 700)
	SETCOLOR 0x00FF00
	PRINT (
	RESETCOLOR
	PRINTFORM {LPIP:0}
	SETCOLOR 0xFFFF00
	CALL PRTOPERATOR, 計算パターン/10%10
	RESETCOLOR
	PRINTFORM {LPIP:1}
	SETCOLOR 0x00FF00
	PRINT )
	CALL PRTOPERATOR, 計算パターン/100
	PRINT (
	RESETCOLOR
	PRINTFORM {LPIP:2}
	SETCOLOR 0xFFFF00
	CALL PRTOPERATOR, 計算パターン%10
	RESETCOLOR
	PRINTFORM {LPIP:3}
	SETCOLOR 0x00FF00
	PRINT )
	RESETCOLOR
ENDIF

;演算子を出力する
;＆は単純な結合
@PRTOPERATOR, 演算子
#DIM DYNAMIC 演算子

SELECTCASE 演算子%6
	CASE 1
		PRINT ＋
	CASE 2
		PRINT ×
	CASE 3
		PRINT －
	CASE 4
		PRINT ÷
	CASE 5
		PRINT ＾
	CASEELSE
		PRINT ＆
ENDSELECT


;変数「答え」がLPIP:0からLPIP:3で計算可能かどうかを判定する
;順番を入れ替えた24通り全てで判別し、
;計算可能な場合、計算パターンをCALC_PTに、その順列をCALC_VAL:0,CALC_VAL:1,CALC_VAL:2,CALC_VAL:3に出力し、1を返す
;計算不可能な場合、0を返す
@ISCALC24, 答え, LPIP0, LPIP:1, LPIP:2, LPIP:3
#DIM DYNAMIC 答え
#DIM DYNAMIC LPIP, 4

CALC_PT = 0
;計算パターン
;★を演算子として、左から1～6もしくは7～12を対応させる
;(i):((A★B)★C)★D...10101-60606
;(ii):(A★(B★C))★D...10701-11206
;(iii):A★((B★C)★D)...70101-120101
;(iv):A★(B★(C★D))...70701-121206
;(v):(A★B)★(C★D)...111-666
CALC_VAL:0 = 0
CALC_VAL:1 = 0
CALC_VAL:2 = 0
CALC_VAL:3 = 0

IF ISCALC(答え, LPIP:0, LPIP:1, LPIP:2, LPIP:3)
	CALC_PT = ISCALC(答え, LPIP:0, LPIP:1, LPIP:2, LPIP:3)
	CALC_VAL:0 = LPIP:0
	CALC_VAL:1 = LPIP:1
	CALC_VAL:2 = LPIP:2
	CALC_VAL:3 = LPIP:3
	RETURN 1
ELSEIF ISCALC(答え, LPIP:0, LPIP:1, LPIP:3, LPIP:2)
	CALC_PT = ISCALC(答え, LPIP:0, LPIP:1, LPIP:3, LPIP:2)
	CALC_VAL:0 = LPIP:0
	CALC_VAL:1 = LPIP:1
	CALC_VAL:2 = LPIP:3
	CALC_VAL:3 = LPIP:2
	RETURN 1
ELSEIF ISCALC(答え, LPIP:0, LPIP:2, LPIP:1, LPIP:3)
	CALC_PT = ISCALC(答え, LPIP:0, LPIP:2, LPIP:1, LPIP:3)
	CALC_VAL:0 = LPIP:0
	CALC_VAL:1 = LPIP:2
	CALC_VAL:2 = LPIP:1
	CALC_VAL:3 = LPIP:3
	RETURN 1
ELSEIF ISCALC(答え, LPIP:0, LPIP:2, LPIP:3, LPIP:1)
	CALC_PT = ISCALC(答え, LPIP:0, LPIP:2, LPIP:3, LPIP:1)
	CALC_VAL:0 = LPIP:0
	CALC_VAL:1 = LPIP:2
	CALC_VAL:2 = LPIP:3
	CALC_VAL:3 = LPIP:1
	RETURN 1
ELSEIF ISCALC(答え, LPIP:0, LPIP:3, LPIP:1, LPIP:2)
	CALC_PT = ISCALC(答え, LPIP:0, LPIP:3, LPIP:1, LPIP:2)
	CALC_VAL:0 = LPIP:0
	CALC_VAL:1 = LPIP:3
	CALC_VAL:2 = LPIP:1
	CALC_VAL:3 = LPIP:2
	RETURN 1
ELSEIF ISCALC(答え, LPIP:0, LPIP:3, LPIP:2, LPIP:1)
	CALC_PT = ISCALC(答え, LPIP:0, LPIP:3, LPIP:2, LPIP:1)
	CALC_VAL:0 = LPIP:0
	CALC_VAL:1 = LPIP:3
	CALC_VAL:2 = LPIP:2
	CALC_VAL:3 = LPIP:1
	RETURN 1
ELSEIF ISCALC(答え, LPIP:1, LPIP:0, LPIP:2, LPIP:3)
	CALC_PT = ISCALC(答え, LPIP:1, LPIP:0, LPIP:2, LPIP:3)
	CALC_VAL:0 = LPIP:1
	CALC_VAL:1 = LPIP:0
	CALC_VAL:2 = LPIP:2
	CALC_VAL:3 = LPIP:3
	RETURN 1
ELSEIF ISCALC(答え, LPIP:1, LPIP:0, LPIP:3, LPIP:2)
	CALC_PT = ISCALC(答え, LPIP:1, LPIP:0, LPIP:3, LPIP:2)
	CALC_VAL:0 = LPIP:1
	CALC_VAL:1 = LPIP:0
	CALC_VAL:2 = LPIP:3
	CALC_VAL:3 = LPIP:2
	RETURN 1
ELSEIF ISCALC(答え, LPIP:1, LPIP:2, LPIP:0, LPIP:3)
	CALC_PT = ISCALC(答え, LPIP:1, LPIP:2, LPIP:0, LPIP:3)
	CALC_VAL:0 = LPIP:1
	CALC_VAL:1 = LPIP:2
	CALC_VAL:2 = LPIP:0
	CALC_VAL:3 = LPIP:3
	RETURN 1
ELSEIF ISCALC(答え, LPIP:1, LPIP:2, LPIP:3, LPIP:0)
	CALC_PT = ISCALC(答え, LPIP:1, LPIP:2, LPIP:3, LPIP:0)
	CALC_VAL:0 = LPIP:1
	CALC_VAL:1 = LPIP:2
	CALC_VAL:2 = LPIP:3
	CALC_VAL:3 = LPIP:0
	RETURN 1
ELSEIF ISCALC(答え, LPIP:1, LPIP:3, LPIP:0, LPIP:2)
	CALC_PT = ISCALC(答え, LPIP:1, LPIP:3, LPIP:0, LPIP:2)
	CALC_VAL:0 = LPIP:1
	CALC_VAL:1 = LPIP:3
	CALC_VAL:2 = LPIP:0
	CALC_VAL:3 = LPIP:2
	RETURN 1
ELSEIF ISCALC(答え, LPIP:1, LPIP:3, LPIP:2, LPIP:0)
	CALC_PT = ISCALC(答え, LPIP:1, LPIP:3, LPIP:2, LPIP:0)
	CALC_VAL:0 = LPIP:1
	CALC_VAL:1 = LPIP:3
	CALC_VAL:2 = LPIP:2
	CALC_VAL:3 = LPIP:0
	RETURN 1
ELSEIF ISCALC(答え, LPIP:2, LPIP:0, LPIP:1, LPIP:3)
	CALC_PT = ISCALC(答え, LPIP:2, LPIP:0, LPIP:1, LPIP:3)
	CALC_VAL:0 = LPIP:2
	CALC_VAL:1 = LPIP:0
	CALC_VAL:2 = LPIP:1
	CALC_VAL:3 = LPIP:3
	RETURN 1
ELSEIF ISCALC(答え, LPIP:2, LPIP:0, LPIP:3, LPIP:1)
	CALC_PT = ISCALC(答え, LPIP:2, LPIP:0, LPIP:3, LPIP:1)
	CALC_VAL:0 = LPIP:2
	CALC_VAL:1 = LPIP:0
	CALC_VAL:2 = LPIP:3
	CALC_VAL:3 = LPIP:1
	RETURN 1
ELSEIF ISCALC(答え, LPIP:2, LPIP:1, LPIP:0, LPIP:3)
	CALC_PT = ISCALC(答え, LPIP:2, LPIP:1, LPIP:0, LPIP:3)
	CALC_VAL:0 = LPIP:2
	CALC_VAL:1 = LPIP:1
	CALC_VAL:2 = LPIP:0
	CALC_VAL:3 = LPIP:3
	RETURN 1
ELSEIF ISCALC(答え, LPIP:2, LPIP:1, LPIP:3, LPIP:0)
	CALC_PT = ISCALC(答え, LPIP:2, LPIP:1, LPIP:3, LPIP:0)
	CALC_VAL:0 = LPIP:2
	CALC_VAL:1 = LPIP:1
	CALC_VAL:2 = LPIP:3
	CALC_VAL:3 = LPIP:0
	RETURN 1
ELSEIF ISCALC(答え, LPIP:2, LPIP:3, LPIP:0, LPIP:1)
	CALC_PT = ISCALC(答え, LPIP:2, LPIP:3, LPIP:0, LPIP:1)
	CALC_VAL:0 = LPIP:2
	CALC_VAL:1 = LPIP:3
	CALC_VAL:2 = LPIP:0
	CALC_VAL:3 = LPIP:1
	RETURN 1
ELSEIF ISCALC(答え, LPIP:2, LPIP:3, LPIP:1, LPIP:0)
	CALC_PT = ISCALC(答え, LPIP:2, LPIP:3, LPIP:1, LPIP:0)
	CALC_VAL:0 = LPIP:2
	CALC_VAL:1 = LPIP:3
	CALC_VAL:2 = LPIP:1
	CALC_VAL:3 = LPIP:0
	RETURN 1
ELSEIF ISCALC(答え, LPIP:3, LPIP:0, LPIP:1, LPIP:2)
	CALC_PT = ISCALC(答え, LPIP:3, LPIP:0, LPIP:1, LPIP:2)
	CALC_VAL:0 = LPIP:3
	CALC_VAL:1 = LPIP:0
	CALC_VAL:2 = LPIP:1
	CALC_VAL:3 = LPIP:2
	RETURN 1
ELSEIF ISCALC(答え, LPIP:3, LPIP:0, LPIP:2, LPIP:1)
	CALC_PT = ISCALC(答え, LPIP:3, LPIP:0, LPIP:2, LPIP:1)
	CALC_VAL:0 = LPIP:3
	CALC_VAL:1 = LPIP:0
	CALC_VAL:2 = LPIP:2
	CALC_VAL:3 = LPIP:1
	RETURN 1
ELSEIF ISCALC(答え, LPIP:3, LPIP:1, LPIP:0, LPIP:2)
	CALC_PT = ISCALC(答え, LPIP:3, LPIP:1, LPIP:0, LPIP:2)
	CALC_VAL:0 = LPIP:3
	CALC_VAL:1 = LPIP:1
	CALC_VAL:2 = LPIP:0
	CALC_VAL:3 = LPIP:2
	RETURN 1
ELSEIF ISCALC(答え, LPIP:3, LPIP:1, LPIP:2, LPIP:0)
	CALC_PT = ISCALC(答え, LPIP:3, LPIP:1, LPIP:2, LPIP:0)
	CALC_VAL:0 = LPIP:3
	CALC_VAL:1 = LPIP:1
	CALC_VAL:2 = LPIP:2
	CALC_VAL:3 = LPIP:0
	RETURN 1
ELSEIF ISCALC(答え, LPIP:3, LPIP:2, LPIP:0, LPIP:1)
	CALC_PT = ISCALC(答え, LPIP:3, LPIP:2, LPIP:0, LPIP:1)
	CALC_VAL:0 = LPIP:3
	CALC_VAL:1 = LPIP:2
	CALC_VAL:2 = LPIP:0
	CALC_VAL:3 = LPIP:1
	RETURN 1
ELSEIF ISCALC(答え, LPIP:3, LPIP:2, LPIP:1, LPIP:0)
	CALC_PT = ISCALC(答え, LPIP:3, LPIP:2, LPIP:1, LPIP:0)
	CALC_VAL:0 = LPIP:3
	CALC_VAL:1 = LPIP:2
	CALC_VAL:2 = LPIP:1
	CALC_VAL:3 = LPIP:0
	RETURN 1
ELSE
	RETURN 0
ENDIF


;自然数「計算結果」がLPIP:0からLPIP:3を用いて計算可能かどうかを判定する
;ただし、順番は入れ替えられない
;計算が可能なとき、計算の順番と演算子に対応した返り値を出す
;★を演算子として、左から1～6もしくは7～12を対応させる
;(i):((A★B)★C)★D...10101-60606
;(ii):(A★(B★C))★D...10701-11206
;(iii):A★((B★C)★D)...70101-120101
;(iv):A★(B★(C★D))...70701-121206
;(v):(A★B)★(C★D)...111-666
@ISCALC(計算結果,LPIP:0,LPIP:1,LPIP:2,LPIP:3)
#FUNCTION
#DIM DYNAMIC 計算結果
#DIM DYNAMIC LPIP, 4
#DIM DYNAMIC LCOUNT, 3

;以下演算子(+,-,*,/,累乗,結合)を★、
;LPIP:0-LPIP:3をそれぞれA-Dとする
;(i):((A★B)★C)★D...10101-60606
FOR LCOUNT, 1, PD_RULE
	FOR LCOUNT:1, 1, PD_RULE
		FOR LCOUNT:2, 1, PD_RULE
			CALC_ERR = 0
			FRAC:0:0 = 0
			FRAC:0:1 = 0
			IF CALC(CALC(CALC(LPIP:0,LPIP:1,LCOUNT:2),LPIP:2,LCOUNT:1),LPIP:3,LCOUNT) == 計算結果
				SIF CALC_ERR == 0 && FRAC:0:1 == 0
					RETURNF LCOUNT*10000+LCOUNT:1*100+LCOUNT:2
			ENDIF
		NEXT
	NEXT
NEXT
;(ii):(A★(B★C))★D...10701-11206
FOR LCOUNT, 1, PD_RULE
	FOR LCOUNT:1, 1, PD_RULE
		FOR LCOUNT:2, 1, PD_RULE
			CALC_ERR = 0
			FRAC:0:0 = 0
			FRAC:0:1 = 0
			IF CALC(CALC2(LPIP:0,CALC(LPIP:1,LPIP:2,LCOUNT:2),LCOUNT:1),LPIP:3,LCOUNT) == 計算結果
				SIF CALC_ERR == 0 && FRAC:0:1 == 0
					RETURNF LCOUNT*10000+(LCOUNT:1+6)*100+LCOUNT:2
			ENDIF
		NEXT
	NEXT
NEXT
;(iii):A★((B★C)★D)...70101-120101
FOR LCOUNT, 1, PD_RULE
	FOR LCOUNT:1, 1, PD_RULE
		FOR LCOUNT:2, 1, PD_RULE
			CALC_ERR = 0
			FRAC:0:0 = 0
			FRAC:0:1 = 0
			IF CALC2(LPIP:0,CALC(CALC(LPIP:1,LPIP:2,LCOUNT:2),LPIP:3,LCOUNT:1),LCOUNT) == 計算結果
				SIF CALC_ERR == 0 && FRAC:0:1 == 0
					RETURNF (LCOUNT+6)*10000+LCOUNT:1*100+LCOUNT:2
			ENDIF
		NEXT
	NEXT
NEXT
;(iv):A★(B★(C★D))...70701-121206
FOR LCOUNT, 1, PD_RULE
	FOR LCOUNT:1, 1, PD_RULE
		FOR LCOUNT:2, 1, PD_RULE
			CALC_ERR = 0
			FRAC:0:0 = 0
			FRAC:0:1 = 0
			IF CALC2(LPIP:0,CALC2(LPIP:1,CALC(LPIP:2,LPIP:3,LCOUNT:2),LCOUNT:1),LCOUNT) == 計算結果
				SIF CALC_ERR == 0 && FRAC:0:1 == 0
					RETURNF (LCOUNT+6)*10000+(LCOUNT:1+6)*100+LCOUNT:2
			ENDIF
		NEXT
	NEXT
NEXT
;(v):(A★B)★(C★D)...111-666
FOR LCOUNT, 1, PD_RULE
	FOR LCOUNT:1, 1, PD_RULE
		FOR LCOUNT:2, 1, PD_RULE
			CALC_ERR = 0
			FRAC:0:0 = 0
			FRAC:0:1 = 0
			FRAC:1:0 = 0
			FRAC:1:1 = 0
			IF CALC3(CALC(LPIP:0,LPIP:1,LCOUNT:1),CALC1(LPIP:2,LPIP:3,LCOUNT:2),LCOUNT) == 計算結果
				SIF CALC_ERR == 0
					RETURNF LCOUNT*100+LCOUNT:1*10+LCOUNT:2
			ENDIF
		NEXT
	NEXT
NEXT
RETURNF 0

;以下演算(1:+ 2:* 3:- 4:/ 5:累乗 6:結合)の処理
;やっちゃ駄目な計算をするとCALC_ERRに1が代入される

;変数「演算子」には対応する値(1:+ 2:* 3:- 4:/ 5:累乗 6:結合)が入っている
;CALCに対し帯分数がくるとき、すなわちFLACに値が入っているとき、必ずINT0に付いているものとみなす
@CALC(INT0,INT1,演算子)
#FUNCTION
#DIM DYNAMIC INT0
#DIM DYNAMIC INT1
#DIM DYNAMIC 演算子
#DIM DYNAMIC 返り値

;分母が0なら分子も0にしておく
SIF FRAC:0:1 == 0
	FRAC:0:0 = 0

;足し算
IF 演算子 == 1
	RETURNF INT0 + INT1
;掛け算
ELSEIF 演算子 == 2
	FRAC:0:0 *= INT1
	FRAC:0:0 /= REDUCTION(FRAC:0:0, FRAC:0:1)
	FRAC:0:1 /= REDUCTION(FRAC:0:0, FRAC:0:1)
	;約分して分母が1になったとき
	IF FRAC:0:1 == 1
		FRAC:0:1 = 0
		RETURNF INT0*INT1 + FRAC:0:0
	ENDIF
	RETURNF INT0 * INT1
;引き算
ELSEIF 演算子 == 3
	RETURNF INT0 - INT1
;割り算
ELSEIF 演算子 == 4
	IF INT1 == 0;0で割らないように
		CALC_ERR = 1
		RETURNF 0
	ELSE
		IF FRAC:0:1 != 0;帯分数を割るとき、仮分数に直し普通の割り算に帰着させる
			INT0 = FRAC:0:0 + INT0*FRAC:0:1
			INT1 *= FRAC:0:1
		ENDIF
		IF INT0 % INT1 != 0;割り切れないとき、帯分数に
			FRAC:0:0 = INT0 - INT1*(INT0 / INT1)
			FRAC:0:1 = INT1
		ENDIF
		;ここから約分
		FRAC:0:0 /= REDUCTION(FRAC:0:0, FRAC:0:1)
		FRAC:0:1 /= REDUCTION(FRAC:0:0, FRAC:0:1)
		;元から分数があるとき割り算をしても分数は減らないのでそのまま返す
		RETURNF INT0 / INT1
	ENDIF
;累乗
ELSEIF 演算子 == 5
	IF INT1 == 0
		RETURNF 1
	ELSEIF INT0 == 0
		RETURNF 0
	ELSEIF INT1*(1+LOG10(ABS(INT0))) > 16;答えが1京を超えないように
		CALC_ERR = 1
		RETURNF 0
	ELSEIF FRAC:0:1 != 0
		FRAC:0:0 += INT0*FRAC:0:1;仮分数に直す
		IF FRAC:0:0 == 0
			RETURNF 0
		ELSEIF INT1*(1+LOG10(ABS(FRAC:0:0))) > 16 || INT1*(1+LOG10(ABS(FRAC:0:1))) > 16
			CALC_ERR = 0
			RETURNF 0
		ELSE
			FRAC:0:0 = POWER(FRAC:0:0, INT1)
			FRAC:0:1 = POWER(FRAC:0:1, INT1)
			返り値 = FRAC:0:0 / FRAC:0:1
			FRAC:0:0 -= 返り値*FRAC:0:1
			RETURNF 返り値
		ENDIF
	ELSE
		RETURNF POWER(INT0,INT1)
	ENDIF
;結合
ELSEIF 演算子 == 6
	IF FRAC:0:1 != 0;帯分数が入っている状態で結合はできない
		CALC_ERR = 1
		RETURNF 0
	ENDIF
	IF INT0 == 0 || INT1 < 0
		CALC_ERR = 1
		RETURNF 0
	ELSEIF INT1 == 0
		RETURNF 10*INT0
	ELSE
		RETURNF POWER(10,1+LOG10(INT1))*INT0+SIGN(INT0)*INT1
	ENDIF
ELSE
	CALC_ERR = 1
	RETURNF 0
ENDIF


;CALC1は最初の計算でしか使われることはない(あらかじめFRACに値は入っていない)
;また答えが分数になるときFRAC:1に代入される
@CALC1(INT0,INT1,演算子)
#FUNCTION
#DIM DYNAMIC INT0
#DIM DYNAMIC INT1
#DIM DYNAMIC 演算子

IF 演算子 == 1
	RETURNF INT0 + INT1
ELSEIF 演算子 == 2
	RETURNF INT0 * INT1
ELSEIF 演算子 == 3
	RETURNF INT0 - INT1
ELSEIF 演算子 == 4
	IF INT1 == 0;0で割らないように
		CALC_ERR = 1
		RETURNF 0
	ELSE
		IF INT0 % INT1 != 0;割り切れないとき、帯分数に
			FRAC:1:0 = INT0 - INT1*(INT0/INT1)
			FRAC:1:1 = INT1
		ENDIF
		FRAC:1:0 /= REDUCTION(FRAC:1:0, FRAC:1:1)
		FRAC:1:1 /= REDUCTION(FRAC:1:0, FRAC:1:1)
		RETURNF INT0 / INT1
	ENDIF
ELSEIF 演算子 == 5
	;0^0=1としている
	IF INT1 == 0
		RETURNF 1
	;0を0乗以外で0
	ELSEIF INT0 == 0
		RETURNF 0
	;答えが1京を超えないように
	ELSEIF INT1*(1+LOG10(ABS(INT0))) > 16
		CALC_ERR = 1
		RETURNF 0
	ELSE
		RETURNF POWER(INT0,INT1)
	ENDIF
ELSEIF 演算子 == 6
	IF INT0 == 0 || INT1 < 0
		CALC_ERR = 1
		RETURNF 0
	ELSEIF INT1 == 0
		RETURNF 10*INT0
	ELSE
		RETURNF POWER(10,1+LOG10(INT1))*INT0+SIGN(INT0)*INT1
	ENDIF
ELSE
	CALC_ERR = 1
	RETURNF 0
ENDIF


;CALCに対し帯分数がくるとき、すなわちFLACに値が入っているとき、必ずINT1に付いているものとみなす
@CALC2(INT0,INT1,演算子)
#FUNCTION
#DIM DYNAMIC INT0
#DIM DYNAMIC INT1
#DIM DYNAMIC 演算子

;分母が0なら分子も0にしておく
SIF FRAC:0:1 == 0
	FRAC:0:0 = 0

IF 演算子 == 1
	RETURNF INT0 + INT1
ELSEIF 演算子 == 2
	FRAC:0:0 *= INT0
	;ここから約分
	FRAC:0:0 /= REDUCTION(FRAC:0:0, FRAC:0:1)
	FRAC:0:1 /= REDUCTION(FRAC:0:0, FRAC:0:1)
	IF FRAC:0:1 == 1
		FRAC:0:1 = 0
		RETURNF INT0*INT1 + FRAC:0:0
	ENDIF
	RETURNF INT0 * INT1
ELSEIF 演算子 == 3
	FRAC:0:0 *= -1
	RETURNF INT0 - INT1
ELSEIF 演算子 == 4
	IF INT1 == 0;0で割らないように
		CALC_ERR = 1
		RETURNF 0
	ELSE
		IF FRAC:0:1 != 0;帯分数で割るとき、仮分数に直し普通の割り算に帰着させる
			INT0 *= FRAC:0:1
			INT1 = FRAC:0:0 + INT1*FRAC:0:1
		ENDIF
		IF INT1 == 0;0で割らないように
			CALC_ERR = 1
			RETURNF 0
		ENDIF
		IF INT0 % INT1 != 0;割り切れないとき、帯分数に
			FRAC:0:0 = INT0 - INT1*(INT0/INT1)
			FRAC:0:1 = INT1
		ENDIF
		;ここから約分
		FRAC:0:0 /= REDUCTION(FRAC:0:0, FRAC:0:1)
		FRAC:0:1 /= REDUCTION(FRAC:0:0, FRAC:0:1)
		IF FRAC:0:1 == 1
			FRAC:0:1 = 0
			RETURNF INT0/INT1 + FRAC:0:0
		ELSE
			RETURNF INT0/INT1
		ENDIF
	ENDIF
ELSEIF 演算子 == 5
	;整数乗でないパターンを最初に計算
	IF FRAC:0:1 != 0
		FRAC:0:0 += INT1 * FRAC:0:1;仮分数に直す
		FRAC:0:0 /= REDUCTION(FRAC:0:0, FRAC:0:1)
		FRAC:0:1 /= REDUCTION(FRAC:0:0, FRAC:0:1)
		;LOG10(0)回避
		IF INT0 == 0
			IF FRAC:0:0 == 0
				RETURNF 1
			ELSE
				RETURNF 0
			ENDIF
		;負の数の非整数乗はダメ
		;答えが1京より大きいのもダメ
		ELSEIF FRAC:0:0 < 0 || FRAC:0:0*(1+LOG10(ABS(INT0)))/FRAC:0:1 > 16
			CALC_ERR = 1
			RETURNF 0
		ELSEIF FRAC:0:1 == 2 && INT0 == POWER(SQRT(ABS(INT0)), 2);2乗根が計算できるとき
			FRAC:0:1 = 0
			INT0 = SQRT(INT0)
			RETURNF POWER(INT0, FRAC:0:0)
		ELSEIF FRAC:0:1 == 3 && ABS(INT0) == POWER(CBRT(ABS(INT0)), 3);3乗根が計算できるとき
			FRAC:0:1 = 0
			INT0 = SIGN(INT0)*CBRT(ABS(INT0))
			RETURNF POWER(INT0, FRAC:0:0)
		ELSEIF FRAC:0:1 == 4 && INT0 == POWER(SQRT(SQRT(ABS(INT0))), 4);4乗根が計算できるとき
			FRAC:0:1 = 0
			INT0 = SQRT(SQRT(INT0))
			RETURNF POWER(INT0, FRAC:0:0)
		ENDIF
		;これ以外のパターンは計算不能とする
		CALC_ERR = 1
		RETURNF 0
	ELSEIF INT0 == 0
		IF INT1 == 0
			RETURNF 1
		ELSE
			RETURNF 0
		ENDIF
	ELSEIF INT1*(1+LOG10(ABS(INT0))) > 16;答えが1京を超えないように
		CALC_ERR = 1
		RETURNF 0
	ELSE
		RETURNF POWER(INT0,INT1)
	ENDIF
ELSEIF 演算子 == 6
	IF FRAC:0:1 != 0;帯分数が入っている状態で結合はできない
		CALC_ERR = 1
		RETURNF 0
	ENDIF
	IF INT0 == 0 || INT1 < 0
		CALC_ERR = 1
		RETURNF 0
	ELSEIF INT1 == 0
		RETURNF 10*INT0
	ELSE
		RETURNF POWER(10,1+LOG10(INT1))*INT0+SIGN(INT0)*INT1
	ENDIF
ELSE
	CALC_ERR = 1
	RETURNF 0
ENDIF


;CALC3に対しては帯分数はどちらにも入りうる
;また、「分母が異なる既約分数の和は整数にならない」という性質を使う
@CALC3(INT0,INT1,演算子)
#FUNCTION
#DIM DYNAMIC INT0
#DIM DYNAMIC INT1
#DIM DYNAMIC 演算子

;分母が0なら分子も0にしておく
SIF FRAC:0:1 == 0
	FRAC:0:0 = 0
SIF FRAC:1:1 == 0
	FRAC:1:0 = 0

IF 演算子 == 1
	;分母が異なるとダメ
	SIF FRAC:0:1 != FRAC:1:1
		CALC_ERR = 1
	;分母は同じだが分子を足し算して分母で割り切れなければダメ
	SIF FRAC:0:1 != 0 && (FRAC:0:0+FRAC:1:0)%FRAC:0:1 != 0
		CALC_ERR = 1
	SIF FRAC:0:1 == 0
		FRAC:0:1 = 1;ゼロ除算対策
	RETURNF INT0 + INT1 + (FRAC:0:0+FRAC:1:0) / FRAC:0:1
ELSEIF 演算子 == 2
	;どちらも分数でないとき
	SIF FRAC:0:1 == 0 && FRAC:1:1 == 0
		RETURNF INT0 * INT1
	IF FRAC:1:1 == 0;FRAC:0は存在する
		FRAC:0:0 *= INT1
		SIF FRAC:0:0 % FRAC:0:1 != 0
			CALC_ERR = 1;答えは整数ではない
		RETURNF INT0 * INT1 + FRAC:0:0/FRAC:0:1
	ELSEIF FRAC:0:1 == 0;FRAC:1は存在する
		FRAC:1:0 *= INT0
		SIF FRAC:1:0 % FRAC:1:1 != 0
			CALC_ERR = 1;答えは整数ではない
		RETURNF INT0 * INT1 + FRAC:1:0/FRAC:1:1
	ELSE ;FRAC:0とFRAC:1は存在する
		;全て仮分数に直す
		FRAC:0:0 += FRAC:0:1 * INT0
		FRAC:1:0 += FRAC:1:1 * INT1
		SIF (FRAC:0:0 * FRAC:1:0) % (FRAC:0:1 * FRAC:1:1) != 0
			CALC_ERR = 1
		RETURNF (FRAC:0:0 * FRAC:1:0) / (FRAC:0:1 * FRAC:1:1)
	ENDIF
ELSEIF 演算子 == 3
	;分母が異なるとダメ
	SIF FRAC:0:1 != FRAC:1:1
		CALC_ERR = 1
	;分母は同じだが分子を足し算して分母で割り切れなければダメ
	SIF FRAC:0:1 != 0 && (FRAC:0:0-FRAC:1:0)%FRAC:0:1 != 0
		CALC_ERR = 1
	SIF FRAC:0:1 == 0
		FRAC:0:1 = 1;ゼロ除算対策
	RETURNF INT0 - INT1 + (FRAC:0:0-FRAC:1:0) / FRAC:0:1
ELSEIF 演算子 == 4
	IF INT1 == 0;0で割らないように
		CALC_ERR = 1
		RETURNF 0
	ELSE
		;全て仮分数に直す
		IF FRAC:0:1 == 0
			FRAC:0:0 = INT0
			FRAC:0:1 = 1
		ELSE
			FRAC:0:0 += FRAC:0:1 * INT0
		ENDIF
		IF FRAC:1:1 == 0
			FRAC:1:0 = INT1
			FRAC:1:1 = 1
		ELSE
			FRAC:1:0 += FRAC:1:1 * INT1
		ENDIF
		SIF (FRAC:0:0 * FRAC:1:1) % (FRAC:0:1 * FRAC:1:0) != 0
			CALC_ERR = 1
		RETURNF (FRAC:0:0 * FRAC:1:1) / (FRAC:0:1 * FRAC:1:0)
	ENDIF
ELSEIF 演算子 == 5
	;既約分数を有理数乗しても整数にならないのでダメ
	IF FRAC:0:1 != 0
		CALC_ERR = 1
		RETURNF 0
	;整数の非整数乗
	ELSEIF FRAC:1:1 != 0
		FRAC:1:0 += INT1 * FRAC:1:1;仮分数に直す
		FRAC:1:0 /= REDUCTION(FRAC:1:0, FRAC:1:1)
		FRAC:1:1 /= REDUCTION(FRAC:1:0, FRAC:1:1)
		;LOG10(0)回避
		IF INT0 == 0
			IF FRAC:1:1 == 0
				RETURNF 1
			ELSE
				RETURNF 0
			ENDIF
		;負の数の非整数乗はダメ
		;答えが1京より大きいのもダメ
		ELSEIF FRAC:1:0 < 0 || FRAC:1:0*(1+LOG10(ABS(INT0)))/FRAC:1:1 > 16
			CALC_ERR = 1
			RETURNF 0
		ELSEIF FRAC:1:1 == 2 && INT0 == POWER(SQRT(ABS(INT0)), 2);2乗根が計算できるとき
			FRAC:1:1 = 0
			INT0 = SQRT(INT0)
			RETURNF POWER(INT0, FRAC:1:0)
		ELSEIF FRAC:1:1 == 3 && ABS(INT0) == POWER(CBRT(ABS(INT0)), 3);3乗根が計算できるとき
			FRAC:1:1 = 0
			INT0 = SIGN(INT0)*CBRT(ABS(INT0))
			RETURNF POWER(INT0, FRAC:1:0)
		ELSEIF FRAC:1:1 == 4 && INT0 == POWER(SQRT(SQRT(ABS(INT0))), 4);4乗根が計算できるとき
			FRAC:1:1 = 0
			INT0 = SQRT(SQRT(INT0))
			RETURNF POWER(INT0, FRAC:1:0)
		ENDIF
		;これ以外のパターンは計算不能とする
		CALC_ERR = 1
		RETURNF 0
	;残りは全部整数同士
	ELSEIF INT0 == 0
		IF INT1 == 0
			RETURNF 1
		ELSE
			RETURNF 0
		ENDIF
	ELSEIF INT1*(1+LOG10(ABS(INT0))) > 16;答えが1京を超えないように
		CALC_ERR = 1
		RETURNF 0
	ELSE
		RETURNF POWER(INT0,INT1)
	ENDIF
ELSEIF 演算子 == 6
	IF FRAC:0:1 != 0 || FRAC:1:1 != 0;帯分数が入っている状態で結合はできない
		CALC_ERR = 1
		RETURNF 0
	ENDIF
	IF INT0 == 0 || INT1 < 0
		CALC_ERR = 1
		RETURNF 0
	ELSEIF INT1 == 0
		RETURNF 10*INT0
	ELSE
		RETURNF POWER(10,1+LOG10(INT1))*INT0+SIGN(INT0)*INT1
	ENDIF
ELSE
	CALC_ERR = 1
	RETURNF 0
ENDIF


;約分用の関数
;GCDと違ってどちらかが0なら特例で1を返す
@REDUCTION(INT_0, INT_1)
#FUNCTION
#DIM DYNAMIC INT_0
#DIM DYNAMIC INT_1
#DIM DYNAMIC L_GCD

L_GCD = GCD(INT_0, INT_1)
IF L_GCD
	RETURNF L_GCD
ELSE
	RETURNF 1
ENDIF


;Greatest Common Divisor(最大公約数)を求める
;ユークリッドの互除法を使用
;ただしどちらかが0のとき特例で0を返すので注意
@GCD(INT_0, INT_1)
#FUNCTION
#DIM DYNAMIC INT_0
#DIM DYNAMIC INT_1
#DIM DYNAMIC INT_L;大きい方
#DIM DYNAMIC INT_S;小さい方
#DIM DYNAMIC INT_R;余り

SIF INT_0*INT_1==0
	RETURNF 0

INT_L = ABS(INT_0)
INT_S = ABS(INT_1)
SIF INT_L < INT_S
	SWAP INT_L, INT_S

DO
	SIF INT_S == 0
		RETURNF INT_L
	INT_R = INT_L % INT_S
	INT_L = INT_S
	INT_S = INT_R
LOOP 1
