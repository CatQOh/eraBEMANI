;;;式中関数「LOOPRES(LOOP RESULT)」
;;;DO～LOOP構文の記述を簡略化するための関数
;;;引数で指定された数字とRESULTを参照し、一致していれば0を返す(つまりLOOPを抜ける)
;;;現在同時に指定できるのは10個まで
@LOOPRES, ARG:0 = __INT_MAX__, ARG:1 = __INT_MAX__, ARG:2 = __INT_MAX__, ARG:3 = __INT_MAX__, ARG:4 = __INT_MAX__, ARG:5 = __INT_MAX__, ARG:6 = __INT_MAX__, ARG:7 = __INT_MAX__, ARG:8 = __INT_MAX__, ARG:9 = __INT_MAX__
#FUNCTION
SIF MATCH(ARG, RESULT)
	RETURNF 0

RETURNF 1

;;;式中関数「SEX」
;;;性別を判別するための関数
;;;引数で指定された対象の性別が、男なら1、女なら2を返す
@SEX, ARG
#FUNCTION
SIF ARG == -1
	RETURNF 0

RETURNF TALENT:ARG:性別

;;;式中関数「CHECK_CHILD_CARE」
;;;育児室に居るかどうか判別するための関数
;;;引数で指定されたキャラを対象に判別する
;;;オリコ「くノ一忍法帖」ならスルー
@CHECK_CHILD_CARE, ARG = -1
#FUNCTION
SIF 受験段位名 == "くノ一忍法帖"
	RETURNF 0
SIF ARG == -1
	RETURNF 0
SIF (TALENT:ARG:妊娠 && PREG:ARG:出産予定日-5 <= DAY) || TALENT:ARG:育児中
	RETURNF 1

RETURNF 0

;;;式中関数「PENIS」
;;;対象にちんこ生えてるかどうか ぱんくしょんにもあったな
;;;ARGが-1だと0を返すので、対象や助手が居ないのに参照してエラーになることはない
@PENIS, ARG
#FUNCTION
SIF ARG == -1
	RETURNF 0
SIF TALENT:ARG:去勢済み
	RETURNF 0
SIF SEX(ARG) == 1 || TALENT:ARG:ふたなり
	RETURNF 1

RETURNF 0

;;;式中関数「VAGINA」
;;;対象にまんこあるかどうか ぱんくしょんにもあったかどうかは知らん
;;;ARGが-1だと0を返すので、対象や助手が居ないのに参照してエラーになることはない
@VAGINA, ARG
#FUNCTION
SIF ARG == -1
	RETURNF 0
SIF SEX(ARG) == 2 || TALENT:ARG:ふたなり
	RETURNF 1

RETURNF 0

;;;式中関数「OVER_GENITAL」
;;;対象の性器を覆い隠している服は何か 一番上の服が返される 下半身上着＝全身上着＞下半身下着＞貞操帯
@OVER_GENITAL, ARG
#FUNCTIONS
SIF ARG == -1
	RETURNF 

IF TEQUIP:ARG:全身上着
	IF CFLAG:ARG:着衣併用 == 2
		IF CSTR:ARG:全身上着 == "逆バニースーツ"
			SIF CFLAG:ARG:貞操帯
				RETURNF "貞操帯"
			RETURNF 
		ELSE
			SIF TEQUIP:ARG:下半身上着
				RETURNF CSTR:ARG:下半身上着
			RETURNF CSTR:ARG:全身上着
		ENDIF
	ELSEIF CFLAG:ARG:着衣併用 == 0
		RETURNF CSTR:ARG:全身上着
	ENDIF
ENDIF

SIF TEQUIP:ARG:下半身上着
	RETURNF CSTR:ARG:下半身上着

SIF TEQUIP:ARG:下半身下着
	RETURNF CSTR:ARG:下半身下着
SIF CFLAG:ARG:貞操帯
	RETURNF "貞操帯"

;;;式中関数「OVER_BUST」
;;;対象の乳房を覆い隠している服は何か 一番上の服が返される 上半身上着＝全身上着＞上半身下着
@OVER_BUST, ARG
#FUNCTIONS
SIF ARG == -1
	RETURNF 

IF TEQUIP:ARG:全身上着
	IF CFLAG:ARG:着衣併用 == 2
		SIF CSTR:ARG:全身上着 == "逆バニースーツ"
			RETURNF
		SIF TEQUIP:ARG:上半身上着
			RETURNF CSTR:ARG:上半身上着 
		RETURNF CSTR:ARG:全身上着
	ELSEIF CFLAG:ARG:着衣併用 == 0
		RETURNF CSTR:ARG:全身上着
	ENDIF
ENDIF

SIF TEQUIP:ARG:上半身上着
	RETURNF CSTR:ARG:上半身上着

SIF TEQUIP:ARG:上半身下着
	RETURNF CSTR:ARG:上半身下着

;;;式中関数「ズリ穴作り」
;;;対象ARGの服が自主的に服に穴などを作ることによりパイズリできる状態かを判別する
;;;ARG:1 = 0 なら通常のパイズリ ARG:1 = 1 なら縦パイズリ
;;;できる場合、1を返す
@ズリ穴作り, ARG, ARG:1
#FUNCTION
SIF ARG == -1
	RETURNF 0

IF TEQUIP:ARG:上半身上着 || (TEQUIP:ARG:全身上着 && CFLAG:ARG:着衣併用!=1)
	IF CFLAG:ARG:上着パイズリ == 5
		IF TEQUIP:ARG:上半身下着
			SELECTCASE CFLAG:ARG:下着パイズリ
				CASE 1
					SIF ARG:1 == 0
						RETURNF 1
				CASE 2
					SIF ARG:1 == 1
						RETURNF 1
				CASE 3
					RETURNF 1
			ENDSELECT
		ELSE
			RETURNF 1
		ENDIF
	ENDIF
ENDIF
RETURNF 0

;;;式中関数「FALLTYPE」
;;;陥落素質のタイプ eraBEMANIでは恋慕系、淫乱系、服従系のどれか一つしか取得できないので、
;;;恋慕or親愛だと1 淫乱or娼婦だと2 服従or隷属だと3を返す 未陥落は0
@FALLTYPE, ARG
#FUNCTION
SIF ARG == -1
	RETURNF 0

IF TALENT:ARG:恋慕 || TALENT:ARG:親愛
	RETURNF 1
ELSEIF TALENT:ARG:淫乱 || TALENT:ARG:娼婦
	RETURNF 2
ELSEIF TALENT:ARG:服従 || TALENT:ARG:隷属
	RETURNF 3
ELSE
	RETURNF 0
ENDIF

;;;式中関数「性器露出」
;;;単に性器が露出している状態かどうかを判別 OVER_GENITALとは少し違う(スカート系が対象にならない)
@性器露出, ARG
#FUNCTION
SIF ARG == -1
	RETURNF 0

SELECTCASE OVER_GENITAL(ARG)
	CASE ""
		RETURNF 1
	CASE "貞操帯"
		RETURNF 1
	CASE CSTR:ARG:下半身上着, CSTR:ARG:全身上着
		IF TEQUIP:ARG:下半身下着
			RETURNF 0
		ELSEIF CFLAG:ARG:挿入可
			RETURNF 1
		ELSE
			RETURNF 0
		ENDIF
	CASE CSTR:ARG:下半身下着
		RETURNF 0
ENDSELECT

RETURNF 0

;;;地の文でよく使うやつを式中関数化
@下半身着衣, ARG
#FUNCTION
SIF TEQUIP:ARG:下半身上着 || (TEQUIP:ARG:全身上着 && CFLAG:ARG:着衣併用 != 1 && CSTR:ARG:全身上着 != "逆バニースーツ")
	RETURNF 1
RETURNF 0

@生殖機能♂, ARG = -1
#FUNCTION
SIF ARG == -1
	RETURNF 0

SIF TALENT:ARG:無機物
	RETURNF 0

SIF CSTR:ARG:種族 == "機械"
	RETURNF 0

SIF TALENT:ARG:ゾンビ
	RETURNF 0

SIF TALENT:ARG:去勢済み
	RETURNF 0

SIF ISSLIME(ARG)
	RETURNF 0

SIF !PENIS(ARG)
	RETURNF 0

SIF TALENT:ARG:霊体
	RETURNF 0

SELECTCASE CFLAG:ARG:精管結紮
	CASE 1
		RETURNF 0
	CASE 2
		SIF CFLAG:ARG:不妊担当魔術師 == NOF(MASTER) || (ASSI >= 0 && CFLAG:ARG:不妊担当魔術師 == NOF(ASSI))
			RETURNF 0
ENDSELECT

;;;上級売春で来たキャラにも無い
SIF 上級売春中 && ARG == TARGET
	RETURNF 0

RETURNF 1

@生殖機能♀, ARG = -1
#FUNCTION
SIF ARG == -1
	RETURNF 0

SIF !VAGINA(ARG)
	RETURNF 0

SIF TALENT:ARG:無機物
	RETURNF 0

SIF CSTR:ARG:種族 == "機械"
	RETURNF 0

SIF ISSLIME(ARG)
	RETURNF 0

SIF TALENT:ARG:霊体
	RETURNF 0

SELECTCASE CFLAG:ARG:卵管結紮
	CASE 1
		RETURNF 0
	CASE 2
		SIF CFLAG:ARG:不妊担当魔術師 == NOF(MASTER) || (ASSI >= 0 && CFLAG:ARG:不妊担当魔術師 == NOF(ASSI))
			RETURNF 0
ENDSELECT

;;;上級売春で来たキャラにも無い
SIF 上級売春中 && ARG == TARGET
	RETURNF 0

RETURNF 1

;;;引数で指定した素質名の番号を返す式中関数
@TALENTF, ARGS
#FUNCTION
#DIM DYNAMIC LCOUNT
FOR LCOUNT, 0, VARSIZE("TALENT")
	SIF TALENTNAME:LCOUNT == ARGS
		RETURNF LCOUNT
NEXT

;#;THROW 素質名「%ARGS%」は存在しないか、表記ゆれです

;;;引数のキャラのNAMEを返すが、NOの範囲が1～9999じゃないと返さない プレイヤーの名前入力による予期せぬ挙動を防ぐため
@CHARANAMEF, ARG
#FUNCTIONS

SIF ARG < 0 || ARG >= CHARANUM
	RETURNF 

SELECTCASE NOF(ARG)
	CASE 1 TO 9999
		RETURNF NAME:ARG
	CASEELSE
		RETURNF 
ENDSELECT

;;;引数のキャラ番号のNAMEを返す。CSVが無い子供の場合はあらかじめ記録しておいたCHILDNAMEを返す
@CSVNAMEF, ARG, ARG:1
#FUNCTIONS
SELECTCASE ARG
	CASE 0 TO 9999
		SIF EXISTCSV(ARG)
			RETURNF CSVNAME(ARG)
	CASE IS < 0
		;#; THROW CSVNAMEFに負の値が渡されています
		RETURNF "[想定外の挙動]"
	CASEELSE
		SIF ARG:1
			RETURNF ""
		RETURNF CHILDNAME:(ARG-10000)
ENDSELECT

;;;引数のキャラ番号のCALLNAMEを返す。CSVが無い子供の場合はあらかじめ記録しておいたCHILDNAMEを返す
@CSVCALLNAMEF, ARG
#FUNCTIONS
SELECTCASE ARG
	CASE 0 TO 9999
		SIF EXISTCSV(ARG)
			RETURNF CSVCALLNAME(ARG)
	CASE IS < 0
		;#; THROW CSVCALLNAMEFに負の値が渡されています
		RETURNF "[想定外の挙動]"
	CASEELSE
		RETURNF CHILDNAME:(ARG-10000)
ENDSELECT

;;;GETCHARAのNAME版 上記CHARANAMEFと同じでNOの範囲が1～9999じゃないと返さない プレイヤーの名前入力による予期せぬ挙動を防ぐため
@GETCHARANAME, ARGS
#FUNCTION
#DIM DYNAMIC LCOUNT

FOR LCOUNT, 0, CHARANUM
	SIF ARGS != NAME:LCOUNT
		CONTINUE
	SIF !INRANGE(NOF(LCOUNT), 1, 9999)
		CONTINUE
	SIF CFLAG:LCOUNT:キャラロスト
		RETURNF -1
	RETURNF LCOUNT
NEXT

RETURNF -1

;;;以下パセリロゴ表示のための関数 式中関数じゃないけどほとんど式中関数みたいな使い方なので
@通貨単位
IF OPTION:パセリ表示
	PRINT_IMG "PASELI"
ELSEIF 通貨単位 != ""
	PRINTFORM %通貨単位%
ELSE
	PRINT $
ENDIF

;;;PRINT
@PASELI, ARGS, 最適化済み
#DIM DYNAMIC LCOUNT
#DIM DYNAMIC LCOUNT2
#DIM DYNAMIC 数字始端
;上限は20くらい取っておく
#DIMS DYNAMIC 表示用, 20
#DIM DYNAMIC 表示数
#DIM DYNAMIC 最適化済み

SPLIT ARGS, "＄", 表示用

表示数 = RESULT

FOR LCOUNT, 0, 表示数
	SIF LCOUNT >= 1
		CALL 通貨単位
	;既に数字がオプション用に最適化されてればすっ飛ばす
	SIF 最適化済み
		GOTO 表示
	数字始端 = -1
	IF ISNUMERIC(CHARATU(表示用:LCOUNT, STRLENSU(表示用:LCOUNT)-1))
		FOR LCOUNT2, STRLENSU(表示用:LCOUNT)-1, -1, -1
			IF ISNUMERIC(CHARATU(表示用:LCOUNT, LCOUNT2))
				数字始端 = LCOUNT2
			ELSE
				BREAK
			ENDIF
		NEXT
	ENDIF
	SELECTCASE 数値表示設定
		CASE "3桁区切り"
			PRINTFORM %SUBSTRINGU(表示用:LCOUNT, 0, 数字始端)%
			SIF 数字始端 >= 0
				PRINTFORM %TODIGSEP(TOINT(SUBSTRINGU(表示用:LCOUNT, 数字始端)))%
		CASE "漢字桁表示"
			PRINTFORM %SUBSTRINGU(表示用:LCOUNT, 0, 数字始端)%
			SIF 数字始端 >= 0
				PRINTFORM %TO漢字(TOINT(SUBSTRINGU(表示用:LCOUNT, 数字始端)))%
		CASEELSE
			$表示
			PRINTFORM %表示用:LCOUNT%
	ENDSELECT
NEXT

;;;PRINTL
@PASELIL, ARGS
CALL PASELI, ARGS
PRINTL 

;;;PRINTW
@PASELIW, ARGS
CALL PASELI, ARGS
PRINTW 

;;;PRINTPLAIN
@PASELIPLAIN, ARGS
#DIM DYNAMIC LCOUNT
#DIM DYNAMIC LCOUNT2
#DIM DYNAMIC 数字始端
;上限は20くらい取っておく
#DIMS DYNAMIC 表示用, 20
#DIM DYNAMIC 表示数

SPLIT ARGS, "＄", 表示用

表示数 = RESULT

FOR LCOUNT, 0, 表示数
	SIF LCOUNT >= 1
		CALL 通貨単位
	数字始端 = -1
	IF ISNUMERIC(CHARATU(表示用:LCOUNT, STRLENSU(表示用:LCOUNT)-1))
		FOR LCOUNT2, STRLENSU(表示用:LCOUNT)-1, -1, -1
			IF ISNUMERIC(CHARATU(表示用:LCOUNT, LCOUNT2)) || LCOUNT2 == 0
				数字始端 = LCOUNT2
			ELSE
				BREAK
			ENDIF
		NEXT
	ENDIF
	SELECTCASE 数値表示設定
		CASE "3桁区切り"
			PRINTPLAINFORM %SUBSTRINGU(表示用:LCOUNT, 0, 数字始端)%
			SIF 数字始端 >= 0
				PRINTPLAINFORM %TODIGSEP(TOINT(SUBSTRINGU(表示用:LCOUNT, 数字始端)))%
		CASE "漢字桁表示"
			PRINTPLAINFORM %SUBSTRINGU(表示用:LCOUNT, 0, 数字始端)%
			SIF 数字始端 >= 0
				PRINTPLAINFORM %TO漢字(TOINT(SUBSTRINGU(表示用:LCOUNT, 数字始端)))%
		CASEELSE
			PRINTPLAINFORM %表示用:LCOUNT%
	ENDSELECT
NEXT

;;;2桁の数値を直接入力するための関数
;;;ARGは最大値
;;;ARGSは単位
;;;ARG:1は最低値
@TWO_DIGIT, 最大値, 単位, 最低値
#DIM 最大値
#DIMS 単位
#DIM 最低値
#DIM DYNAMIC LCOUNT
#DIM DYNAMIC 入力値
#DIMS DYNAMIC HTML用, 2
PRINTL キーボードによる直接入力もできます

DO
	PRINTL
	IF 入力値 >= 10
		PRINTFORM 【 %TOFULL(TOSTR(入力値/10))%
	ELSE
		PRINT 【 　
	ENDIF
	PRINTFORML %TOFULL(TOSTR(入力値%10))% 】%単位%

	
	;一の位は100～109を入力されると決まる RESULT-100とかRESULT%100とか
	;十の位は200～290を入力されると決まる (RESULT-200)/10とか？
	FOR LCOUNT, 0, 10
		VARSET HTML用
		IF 最大値 >= LCOUNT*10 && 最低値 <= LCOUNT*10
			HTML用 = <font color='#c0c0c0'><button value='{200+LCOUNT*10}'>[ {LCOUNT} ]</button></font>
		ELSE
			HTML用 = <font color='#c0c0c0'>     </font>
		ENDIF
		IF 最大値 >= LCOUNT
			HTML用:1 = <font color='#c0c0c0'><button value='{100+LCOUNT}'>[ {LCOUNT} ]</button></font>
		ENDIF
		HTML_PRINT HTML用+HTML用:1
	NEXT
	PRINTBUTTON "[  決定  ]", 999
	PRINTBUTTON "[ 最大値 ]", 最大値
	PRINTBUTTON "[ 最低値 ]", 最低値
	PRINTL 
	INPUT
	
	;キーボード入力で最低値～最大値の範囲内ならそれを返す
	SIF INRANGE(RESULT, 最低値, 最大値)
		RETURN RESULT

	;決定が押されれば入力値の値を返す
	IF RESULT == 999
		IF 入力値 < 最低値
			PRINTFORMW 最低値({最低値})以上の数値を指定してください
			CONTINUE
		ENDIF
		CLEARLINE 1
		RETURN 入力値
	ENDIF

	SELECTCASE RESULT
		;一の位の処理 一の位を0にしてから加算する
		CASE 100 TO 109
			入力値 = (入力値/10)*10+(RESULT-100)
		;十の位の処理 十の位を0にしてから加算する
		CASE 200 TO 290
			;プレイヤーが変なの入力した時用に一の位を抹消する
			RESULT -= RESULT%10
			入力値 = (入力値%10)+(RESULT-200)
	ENDSELECT
	;最低値～最大値を超えてたらそれぞれ最低値か最高値に置き換える
	SIF !INRANGE(入力値, 最低値, 最大値)
		入力値 = LIMIT(入力値, 最低値, 最大値)
	CLEARLINE 14
LOOP 1

;;;素数かどうかを判定する
;;;素数なら1,それ以外(合成数・1以下の整数)なら0
@ISPRIME(ARG)
#FUNCTION
SIF ARG < 2
	RETURNF 0
SIF ARG == 2
	RETURNF 1
SIF ARG % 2 == 0
	RETURNF 0
FOR ARG:1, 3, SQRT(ARG)+1, 2
	SIF ARG % ARG:1 == 0
		RETURNF 0
NEXT
RETURNF 1

;;;平方数(整数を2乗してできる数)なら1を返す式中関数
@ISSQUARE(ARG)
#FUNCTION
SIF ARG < 0
	RETURNF 0
IF ARG == SQRT(ARG)*SQRT(ARG)
	RETURNF 1
ELSE
	RETURNF 0
ENDIF

;;;約数関数
;;;ARGの正の約数全てをARG:1乗した総和を表す
;;;ARG:1が0で約数の個数、ARG:1が1で約数の総和を求める
;;;ARGが0のとき特例で0、ARGが負でABS(ARG)での値にマイナスをつける
@SIGMA(ARG, ARG:1=1)
#FUNCTION
#DIM DYNAMIC LCOUNT
#DIM DYNAMIC LSUM
SIF ARG == 0
	RETURNF 0

FOR LCOUNT, 1, ABS(ARG)+1
	SIF ABS(ARG)%LCOUNT == 0
		LSUM += POWER(LCOUNT, ARG:1)
NEXT
LSUM *= SIGN(ARG)

RETURNF LSUM

;;;整数ARGの4/3乗を返す関数
;;;負の数でもエラーは吐かないようになっている
;;;また、結果をARG:1倍にもできる(3乗根の中で計算するので誤差があまり大きくならない)
;;;係数による2^63エラーの対策はとっていないので注意
@POW4V3(ARG, ARG:1=1)
#FUNCTION
#DIM DYNAMIC LCL
IF ABS(ARG) < 9800
	LCL = CBRT( 1000 * POWER(ARG,4) * POWER(ABS(ARG:1),3) ) / 10
ELSE
	LCL = ABS(ARG) * CBRT( 1000 * ABS(ARG) * POWER(ABS(ARG:1),3) ) / 10
ENDIF
RETURNF LCL

;;;1/ARGの確率を表示
@確率表示, ARG
PRINTFORM 1/{ARG} ({100/ARG}.{(1000/ARG)%10}\%)

;;;1/ARGまたは1/(ARG:1)が起きる確率を表示
@確率表示2, ARG, ARG:1
PRINTFORM {ARG+ARG:1+1}/{ARG*ARG:1} ({ 100*(ARG+ARG:1+1)/(ARG*ARG:1) }.{ (1000*(ARG+ARG:1+1)/(ARG*ARG:1))%10 }\%)

;;;近親相姦の判定用関数
;;;1なら兄弟姉妹間、2なら親子間、それ以外なら0
@近親相姦, ARG, ARG:1
#FUNCTION
SIF ARG < 0 && ARG:1 < 0
	RETURNF 0

IF CFLAG:ARG:血縁コード >= 1 && CFLAG:ARG:血縁コード == CFLAG:(ARG:1):血縁コード
	;夫婦同士なら近親相姦じゃない
	IF GROUPMATCH(CFLAG:ARG:続柄, 1000, 1001) && GROUPMATCH(CFLAG:(ARG:1):続柄, 1000, 1001)
		RETURNF 0
	ELSEIF GROUPMATCH(CFLAG:ARG:続柄, 2000, 2001) && GROUPMATCH(CFLAG:(ARG:1):続柄, 2000, 2001)
		RETURNF 0
	ELSEIF CFLAG:ARG:続柄 >= 1000 || CFLAG:(ARG:1):続柄 >= 1000
		RETURNF 2
	ELSE
		RETURNF 1
	ENDIF
ELSE
	SIF NOF(ARG) >= 10000 && (CFLAG:ARG:血縁コード/100000 == NOF(ARG:1) || CFLAG:ARG:血縁コード%100000 == NOF(ARG:1))
		RETURNF 2
	SIF NOF(ARG:1) >= 10000 && (CFLAG:(ARG:1):血縁コード/100000 == NOF(ARG) || CFLAG:(ARG:1):血縁コード%100000 == NOF(ARG))
		RETURNF 2
ENDIF

RETURNF 0


;;;膣に道具入ってるかどうかの式中関数
@Ｖ使用中, ARG = -1
#FUNCTION
SIF ARG == -1
	RETURNF 0

SIF TEQUIP:ARG:バイブ
	RETURNF 1
SIF TEQUIP:ARG:Ｖ異物
	RETURNF 1
SIF TEQUIP:ARG:ペニスバンド
	RETURNF 1

RETURNF 0

;;;表記ゆれ（半角）にも対応
@V使用中, ARG = -1
#FUNCTION
RETURNF Ｖ使用中(ARG)

;;;アナルに道具入ってるかどうかの式中関数
@Ａ使用中, ARG = -1
#FUNCTION
SIF ARG == -1
	RETURNF 0

SIF TEQUIP:ARG:アナルバイブ
	RETURNF 1
SIF TEQUIP:ARG:アナルビーズ
	RETURNF 1
SIF TEQUIP:ARG:浣腸器
	RETURNF 1
SIF TEQUIP:ARG:拡張バルーン
	RETURNF 1
SIF TEQUIP:ARG:アナル電極
	RETURNF 1
SIF TEQUIP:ARG:Ａ異物
	RETURNF 1
SIF TEQUIP:ARG:電動エネマグラ
	RETURNF 1
SIF TEQUIP:ARG:野外プレイ && アイテム改造:首輪 == "尻尾プラグ付き首輪"
	RETURNF 1

RETURNF 0

;;;表記ゆれ（半角）にも対応
@A使用中, ARG = -1
#FUNCTION
RETURNF Ａ使用中(ARG)

;;;胸で道具使ってるかどうかの式中関数
@Ｂ使用中, ARG = -1
#FUNCTION
SIF ARG == -1
	RETURNF 0

SIF TEQUIP:ARG:ニプルキャップ
	RETURNF 1
SIF TEQUIP:ARG:搾乳器
	RETURNF 1
SIF TEQUIP:ARG:乳房電極
	RETURNF 1
SIF TEQUIP:ARG:触手乳管挿入
	RETURNF 1

RETURNF 0

;;;表記ゆれ（半角）にも対応
@B使用中, ARG = -1
#FUNCTION
RETURNF Ｂ使用中(ARG)

;;;ペニスに道具使ってるかどうかの式中関数
@Ｐ使用中, ARG = -1
#FUNCTION
SIF ARG == -1
	RETURNF 0

SIF TEQUIP:ARG:オナホール
	RETURNF 1
SIF TEQUIP:ARG:搾精器
	RETURNF 1
SIF CFLAG:ARG:貞操帯
	RETURNF 1
SIF TEQUIP:ARG:尿道カテーテル
	RETURNF 1
SIF TEQUIP:ARG:尿道ポッキー
	RETURNF 1

RETURNF 0

;;;コンドーム、搾精コンドームの使用判定
@避妊具, ARG = -1
#FUNCTION
SIF ARG == -1
	RETURNF 0

SIF TEQUIP:ARG:コンドーム
	RETURNF 1
SIF TEQUIP:ARG:搾精コンドーム
	RETURNF 1

RETURNF 0

;;;表記ゆれ（半角）にも対応
@P使用中, ARG = -1
#FUNCTION
RETURNF Ｐ使用中(ARG)

;;;男性器使用不可の判定
@Ｐ使用不可, ARG = -1
#FUNCTION
SIF ARG == -1
	RETURNF 0

SIF CFLAG:ARG:貞操帯
	RETURNF 1
SIF TALENT:ARG:去勢済み
	RETURNF 1
SIF ABL:ARG:メス度 >= 10
	RETURNF 1

RETURNF 0

;;;道具解除系の関数
@Ｖ道具解除, ARG = -1
SIF ARG == -1
	RETURN

TEQUIP:ARG:バイブ = 0
TEQUIP:ARG:Ｖ異物 = 0
TEQUIP:ARG:ペニスバンド = 0

;;;ただし野外プレイ+尻尾プラグは解除不可
@Ａ道具解除, ARG = -1
SIF ARG == -1
	RETURN

TEQUIP:ARG:アナルバイブ = 0
TEQUIP:ARG:アナルビーズ = 0
TEQUIP:ARG:浣腸器 = 0
TEQUIP:ARG:拡張バルーン = 0
TEQUIP:ARG:アナル電極 = 0
TEQUIP:ARG:Ａ異物 = 0
TEQUIP:ARG:電動エネマグラ = 0

;;;道具解除系の関数
@Ｂ道具解除, ARG = -1
SIF ARG == -1
	RETURN

TEQUIP:ARG:ニプルキャップ = 0
TEQUIP:ARG:搾乳器 = 0
TEQUIP:ARG:乳房電極 = 0
TEQUIP:ARG:触手乳管挿入 = 0

;;;道具解除系の関数
@Ｐ道具解除, ARG = -1
SIF ARG == -1
	RETURN

TEQUIP:ARG:オナホール = 0
TEQUIP:ARG:搾精器 = 0

;;;GETNUM(PALAM, "STR")をさらに簡略化したもの。ABL上昇処理で頻繁に使用しているのでPALAM用に作った
;;;GETPALAMLVではない
@GETPALAM, ARGS
#FUNCTION
;#;SIF GETNUM(PALAM, ARGS) == -1
;#;	THROW 能力名「%ARGS%」は存在しないか、表記ゆれです

RETURNF GETNUM(PALAM, ARGS)

;;;GETNUM(EXP, "STR")をさらに簡略化したもの。ABL上昇処理で頻繁に使用しているのでEXP用に作った
;;;GETEXPLVではない
@GETEXP, ARGS
#FUNCTION
;#;SIF GETNUM(EXP, ARGS) == -1
;#;	THROW 経験名「%ARGS%」は存在しないか、表記ゆれです

RETURNF GETNUM(EXP, ARGS)

;;;第一引数に第二引数のツールチップ付けたHTML_PRINT用の完成されたタグを返す式中関数
;;;"[]"で囲った部分があれば自動でボタン化する
;;;ボタン化フラグを0にすればボタン化しない
@SET_TOOLTIP, 本文, ツールチップ, ボタン化 = 1, 文字色
#FUNCTIONS
#DIMS DYNAMIC 本文
#DIMS DYNAMIC ツールチップ
#DIMS DYNAMIC タグ
;ボタンの数値が指定されたボタン番号と一致すると困るので、ボタン化されなさそうな数値に 元ネタ分かる人はすごい
#DIM DYNAMIC ボタン = -3189415
#DIMS DYNAMIC 文字列ボタン
#DIM DYNAMIC ボタン化
#DIMS DYNAMIC 文字色
#DIM DYNAMIC 括弧, 2
;STRCOUNTの使い方がわからない
括弧 = STRFINDU(本文, "[")
括弧:1 = STRFINDU(本文, "]")

IF 括弧 != -1 && 括弧:1 != -1
	;STRFIND系使うと"[～]"の範囲を取得してるので"["と"]"を省くために+1と-1する
	文字列ボタン = %SUBSTRINGU(本文, 括弧+1, 括弧:1-括弧-1)%
	SIF ISNUMERIC(文字列ボタン)
		ボタン = TOINT(文字列ボタン)
ENDIF

;文字色指定してればその文字色で
;μEmueraでは色変更がかなり怪しい挙動するのでしない
IF !SP
	IF 文字色 != ""
		IF COLOR_FROMNAME(文字色) >= 0
			タグ = <font color='%文字色%'>
		ELSEIF ISNUMERIC(文字色)
			タグ = <font color='#%CONVERT(TOINT(文字色), 16)%'>
		ELSE
			GOTO COLORELSE
		ENDIF
	ELSE
		$COLORELSE
		タグ = <font color='#%CONVERT(GETCOLOR(), 16)%'>
	ENDIF
ENDIF

SIF !ボタン化
	GOTO NONBUTTON

;紛らわしいけどtitleがツールチップなんだよなぁ
IF ボタン != -3189415
	IF SP
		タグ += @"<button value ='{ボタン}'>%本文%</button>"
	ELSEIF ツールチップ非表示
		タグ += @"<button value ='{ボタン}'>%本文%</button></font>"
	ELSE
		タグ += @"<button value ='{ボタン}' title = '%ツールチップ%'>%本文%</button></font>"
	ENDIF
ELSEIF 文字列ボタン != ""
	IF SP
		タグ += @"<button value ='%文字列ボタン%'>%本文%</button>"
	ELSEIF ツールチップ非表示
		タグ += @"<button value ='%文字列ボタン%'>%本文%</button></font>"
	ELSE
		タグ += @"<button value ='%文字列ボタン%' title = '%ツールチップ%'>%本文%</button></font>"
	ENDIF
ELSE
	$NONBUTTON
	IF SP
		タグ += @"<nonbutton>%本文%</nonbutton>"
	ELSEIF ツールチップ非表示
		タグ += @"<nonbutton>%本文%</nonbutton></font>"
	ELSE
		タグ += @"<nonbutton title = '%ツールチップ%'>%本文%</nonbutton></font>"
	ENDIF
ENDIF

RETURNF タグ

;;;PRINTBUTTONのツールチップ付与版
;;;PRINTBUTTONと同じ使い方に加え、第三引数のツールチップ付けたHTML_PRINT用の完成されたタグを返す式中関数
;;;ただしPRINTBUTTONとは違い、第二引数がINT型であってもダブルクォーテーションで括らなければならない
@SET_TOOLTIPBUTTON, 本文, 文字列ボタン, ツールチップ, 文字色
#FUNCTIONS
#DIMS DYNAMIC 本文
#DIMS DYNAMIC ツールチップ
#DIMS DYNAMIC タグ
;ボタンの数値が指定されたボタン番号と一致すると困るので、ボタン化されなさそうな数値に 元ネタ分かる人はすごい
#DIM DYNAMIC ボタン = -3189415
#DIMS DYNAMIC 文字列ボタン
#DIM DYNAMIC ボタン化
#DIMS DYNAMIC 文字色
SIF ISNUMERIC(文字列ボタン)
	ボタン = TOINT(文字列ボタン)

;文字色指定してればその文字色で
;μEmueraでは色変更がかなり怪しい挙動するのでしない
IF !SP
	IF 文字色 != ""
		IF COLOR_FROMNAME(文字色) >= 0
			タグ = <font color='%文字色%'>
		ELSEIF ISNUMERIC(文字色)
			タグ = <font color='#%CONVERT(TOINT(文字色), 16)%'>
		ELSE
			GOTO COLORELSE
		ENDIF
	ELSE
		$COLORELSE
		タグ = <font color='#%CONVERT(GETCOLOR(), 16)%'>
	ENDIF
ENDIF

;紛らわしいけどtitleがツールチップなんだよなぁ
IF ボタン != -3189415
	IF SP
		タグ += @"<button value ='{ボタン}'>%本文%</button>"
	ELSEIF ツールチップ非表示
		タグ += @"<button value ='{ボタン}'>%本文%</button></font>"
	ELSE
		タグ += @"<button value ='{ボタン}' title = '%ツールチップ%'>%本文%</button></font>"
	ENDIF
ELSEIF 文字列ボタン != ""
	IF SP
		タグ += @"<button value ='%文字列ボタン%'>%本文%</button>"
	ELSEIF ツールチップ非表示
		タグ += @"<button value ='%文字列ボタン%'>%本文%</button></font>"
	ELSE
		タグ += @"<button value ='%文字列ボタン%' title = '%ツールチップ%'>%本文%</button></font>"
	ENDIF
ENDIF

RETURNF タグ

;;;引数の条件に一致するキャラをページ形式で表示する
;;;詳しくは資料フォルダの雑記.txtを参照
@PAGING, 表示, 追加情報, ページ名, 終了表記, 使用不可も表示
#DIM ページ数
#DIM 表示数
#DIM 飛ばした人数
#DIM 未表示キャラ
#DIM 表示行数
#DIM 選択可能, 10000
#DIM 初期化フラグ
#DIM DYNAMIC LCOUNT
#DIM DYNAMIC 表示
#DIM DYNAMIC 使用不可も表示
#DIM DYNAMIC クジャクアイ
#DIMS DYNAMIC 追加情報
#DIMS DYNAMIC ページ名
#DIMS DYNAMIC 終了表記

LCOUNT = PAGING

IF 初期化フラグ == 0
	VARSET 選択可能
	飛ばした人数 = 0
	表示数 = 0
	未表示キャラ = 0
	表示行数 = LINECOUNT
	初期化フラグ = 1
ENDIF

IF 表示 && (使用不可も表示 || !CFLAG:PAGING:使用不可) && !CFLAG:PAGING:キャラロスト
	;2ページ目以降はページ数×一定数まで表示を飛ばす
	IF 飛ばした人数 < ページ数*PAGING表示数
		飛ばした人数++
		RETURN 0
	ENDIF

	表示数++
	;一定数表示したら未表示キャラが居るフラグ立ててページ終わり
	IF 表示数 > PAGING表示数
		未表示キャラ = 1
	ELSE
		;健康診断は色変えしたいので特別な処理
		IF 追加情報 == "健康診断用"
			PRINTFORM 　[{LCOUNT, 2, RIGHT}] - %NAMEDISP(LCOUNT), 26, LEFT% \@ SEX(LCOUNT) == 1 ? ♂ # ♀ \@ 体力%BARBASE("体力", PAGING, 10), 23, LEFT% 気力%BARBASE("気力", PAGING, 10), 23, LEFT% ストレス値:
			;孔雀の瞳を持ってるキャラが主人・助手・担当医に居るかを見る
			SIF TALENT:MASTER:孔雀の瞳
				クジャクアイ = 1
			SIF ASSI > 0 && TALENT:ASSI:孔雀の瞳
				クジャクアイ = 1
			FOR LCOUNT, 0, CHARANUM
				SIF CSTR:LCOUNT:配属 == "医務室" && TALENT:LCOUNT:孔雀の瞳
					クジャクアイ = 1
			NEXT
			LCOUNT = PAGING
			IF クジャクアイ
				SELECTCASE CFLAG:LCOUNT:ストレス値
					CASE 1 TO 99
						SETCOLORBYNAME lime
					CASE 100 TO 299
						SETCOLORBYNAME yellow
					CASE 300 TO 499
						SETCOLORBYNAME red
					CASE IS >= 500
						SETCOLORBYNAME darkred
				ENDSELECT
				PRINTFORML {CFLAG:LCOUNT:ストレス値}/999
			ELSE
				SELECTCASE CFLAG:LCOUNT:ストレス値
					CASE 0
						PRINTL 無
					CASE 1 TO 99
						SETCOLORBYNAME lime
						PRINTL 低
					CASE 100 TO 299
						SETCOLORBYNAME yellow
						PRINTL 中
					CASE 300 TO 499
						SETCOLORBYNAME red
						PRINTL 高
					CASE IS >= 500
						SETCOLORBYNAME darkred
						PRINTL 過多
				ENDSELECT
				RESETCOLOR
			ENDIF
			選択可能:LCOUNT = 1
		ELSE
			PRINTFORML 　[{LCOUNT, 2, RIGHT}] - %NAMEDISP(LCOUNT), 30, LEFT% \@ SEX(LCOUNT) == 1 ? ♂ # ♀ \@ %追加情報%
			選択可能:LCOUNT = 1
		ENDIF
	ENDIF
ENDIF

;表示数が一定数になるか全キャラ表示したら入力受け付け
IF 表示数 > PAGING表示数 || LCOUNT == CHARANUM-1
	;表示できるキャラが居ない場合
	IF 表示数 == 0
		DRAWLINE
		PRINTL 　表示できるキャラが居ません
	ENDIF
	DRAWLINE
	初期化フラグ = 0
	IF ページ名 == ""
		PRINTPLAINFORM 　PAGE.{ページ数+1}　
	ELSE
		PRINTPLAINFORM 　%ページ名%　
	ENDIF
	IF ページ数 > 0
		PRINTLC [999]前ページ
	ELSE
		PRINTLC  
	ENDIF
	IF 終了表記 == ""
		PRINTLC [1000] 戻る　
	ELSE
		PRINTFORMLC [1000] %終了表記%　
	ENDIF
	;表示できるキャラがまだ居れば次ページ
	SIF 未表示キャラ
		PRINTLC [1001]次ページ
	PRINTL 
	DO
		INPUT
		SELECTCASE RESULT
			CASE 999
				SIF ページ数 > 0
					ページ数--
				PAGING = -1
				CLEARLINE LINECOUNT-表示行数
				RETURN 0
			CASE 1000
				PAGING = CHARANUM
				ページ数 = 0
				RETURN -1
			CASE 1001
				;表示できるキャラがまだ居れば次ページ
				SIF 未表示キャラ
					ページ数++
				PAGING = -1
				CLEARLINE LINECOUNT-表示行数
				RETURN 0
			CASEELSE
				SIF !選択可能:RESULT
					CONTINUE
				PAGING = CHARANUM
				ページ数 = 0
				RETURN RESULT
		ENDSELECT
	LOOP 1
ENDIF

;;;第一引数(比較元)と第二引数(比較先)を比較して、条件で指定した動作を行う
;;;条件=UPの場合 - 比較先が比較元より大きい数だった場合は比較元を同じ値にする
;;;条件=DOWNの場合 - 比較先が比較元より小さい数だった場合は比較元を同じ値にする
;;;条件を指定しない場合はUPの動作 参照型変数なので比較元はこの関数内で変更される
@REF_DIFF, 比較元, 比較先, 条件 = "UP"
#DIM DYNAMIC REF 比較元
#DIM DYNAMIC 比較先
#DIMS DYNAMIC 条件
SELECTCASE 条件
	CASE "UP"
		SIF 比較元 < 比較先
			比較元 = 比較先
	CASE "DOWN"
		SIF 比較元 > 比較先
			比較元 = 比較先
ENDSELECT

;;;上記REF_DIFFの改良版 第一引数が第二引数より大きい場合は第二引数の値に合わせる
@SETMIN, 比較元, 比較先
#DIM DYNAMIC REF 比較元
#DIM DYNAMIC 比較先
SIF 比較元 > 比較先
	比較元 = 比較先

;;;上記SETMINのMAX版 第一引数が第二引数より小さい場合は第二引数の値に合わせる
@SETMAX, 比較元, 比較先
#DIM DYNAMIC REF 比較元
#DIM DYNAMIC 比較先
SIF 比較元 < 比較先
	比較元 = 比較先

;;;BASEのBARを表示する汎用関数
;;;指定が無ければ32分
@BARBASE, ARGS, ARG = -1, ARG:1 = 32
#FUNCTIONS
SIF ARG == -1
	ARG = TARGET
SIF ARG == -1
	RETURNF 

SIF MAXBASE:ARG:ARGS > 0
	RETURNF @"%BARSTR(BASE:ARG:ARGS, MAXBASE:ARG:ARGS, ARG:1)%({BASE:ARG:ARGS}/{MAXBASE:ARG:ARGS})"

;;;対象のBASEがMAXBASEより高かったり0より低かったりしたら合わせる関数
;;;体力気力魔力のみ
@SETBASE, ARG
BASE:ARG:体力 = LIMIT(BASE:ARG:体力, 0, MAXBASE:ARG:体力)
BASE:ARG:気力 = LIMIT(BASE:ARG:気力, 0, MAXBASE:ARG:気力)
BASE:ARG:魔力 = LIMIT(BASE:ARG:魔力, 0, MAXBASE:ARG:魔力)

;;;改行しないウェイトする関数 大犬口上から本体に移動
@SLINEWAIT, ARGS
#DIM DYNAMIC LCOUNT, 2
#DIMS DYNAMIC 表示用, 10
SPLIT ARGS, "Ｗ", 表示用

表示用 = %HTML_POPPRINTINGSTR()%%表示用%

FOR LCOUNT, 0, RESULT
	IF LCOUNT >= 1
		WAIT
		CLEARLINE 1
	ENDIF
	FOR LCOUNT:1, 0, LCOUNT+1
		PRINTFORM %表示用:(LCOUNT:1)%
	NEXT
NEXT
PRINTW 

;;;現在表示してる最後の行がDRAWLINE行かどうかをチェックし、そうでなければDRAWLINEを引く関数
@CHECKDRAWLINE
SIF HTML_TOPLAINTEXT(HTML_GETPRINTEDSTR(0)) != DRAWLINESTR
	DRAWLINE

;;;上記CHECKDRAWLINEのWAIT付き版
@CHECKDRAWLINEW
IF HTML_TOPLAINTEXT(HTML_GETPRINTEDSTR(0)) != DRAWLINESTR
	WAIT
	DRAWLINE
ENDIF

;;;引数のNAMEのキャラのNOを返す 子供にも対応しているが、同姓同名のキャラが入れば番号が若い方が優先される
@GETNO, 名前
#FUNCTION
#DIMS DYNAMIC 名前
#DIMS 名前保存用, 20000
#DIM DYNAMIC LCOUNT
#DIM CHILDNO = 10000

IF 名前保存用 == ""
	$RETRY
	FOR LCOUNT, 0, 20000
		SELECTCASE LCOUNT
			CASE 0 TO 9999
				SIF EXISTCSV(LCOUNT)
					名前保存用:LCOUNT = %CSVNAME(LCOUNT)%
			CASE IS > 10000
				IF CHILDNAME:(LCOUNT-10000) == ""
					CHILDNO = LCOUNT
					BREAK
				ENDIF
				名前保存用:LCOUNT = %CHILDNAME:(LCOUNT-10000)%
		ENDSELECT
	NEXT
ENDIF
;子供が増えてたら再度回す
SIF 名前保存用:CHILDNO != ""
	GOTO RETRY

;#;SIF FINDELEMENT(名前保存用, ESCAPE(名前), 0, VARSIZE("名前保存用"), 1) == -1
;#;	THROW 「%名前%」というキャラは存在しないか、表記揺れです

RETURNF FINDELEMENT(名前保存用, ESCAPE(名前), 0, VARSIZE("名前保存用"), 1)

;;;ストレス値の表示
@ストレス表示, ARG
SIF ARG == -1
	RETURN

SELECTCASE CFLAG:ARG:ストレス値
	CASE 1 TO 99
		SETCOLORBYNAME lime
	CASE 100 TO 299
		SETCOLORBYNAME yellow
	CASE 300 TO 499
		SETCOLORBYNAME red
	CASE IS >= 500
		SETCOLORBYNAME darkred
ENDSELECT
PRINTFORM {CFLAG:ARG:ストレス値}/999
RESETCOLOR

;;;難易度を単語で返す
@難易度, ARG
#FUNCTIONS
SIF ARG == 0
	ARG = FLAG:難易度

IF QMA
	SELECTCASE ARG
		CASE -1
			RETURNF "ビギナー級"
		CASE 1
			RETURNF "フェアリー級"
		CASE 2
			RETURNF "ミノフェニ級"
		CASE 3
			RETURNF "ドラゴン級"
		CASE 4
			RETURNF "レジェンダリア級"
	ENDSELECT
ELSE
	SELECTCASE ARG
		CASE -1
			RETURNF "BEGINNER"
		CASE 1
			RETURNF "NORMAL"
		CASE 2
			RETURNF "HYPER"
		CASE 3
			RETURNF "ANOTHER"
		CASE 4
			RETURNF "LEGGENDARIA"
	ENDSELECT
ENDIF

;;;天気を単語で返す
@天気, ARG
#FUNCTIONS
SIF ARG == 0
	ARG = FLAG:天気

SELECTCASE ARG
	CASE 1
		RETURNF "晴れ"
	CASE 2
		RETURNF "曇り"
	CASE 3
		RETURNF "雨"
	CASE 4
		RETURNF "大雨"
	CASE 5
		RETURNF "雷雨"
	CASE 6
		RETURNF "雪"
	CASE 7
		RETURNF "大雪"
ENDSELECT

;;;月齢を単語で返す
@月齢, ARG = -1
#FUNCTIONS
SIF ARG == -1
	ARG = 月齢

SELECTCASE ARG
	CASE 0 TO 199
		RETURNF "新月"
	CASE 200 TO 299
		RETURNF "繊月"
	CASE 300 TO 699
		RETURNF "三日月"
	CASE 700 TO 999
		RETURNF "上弦の月"
	CASE 1000 TO 1399
		RETURNF "十日夜"
	CASE 1400 TO 1499
		RETURNF "小望月"
	CASE 1500 TO 1599
		RETURNF "満月"
	CASE 1600 TO 1699
		RETURNF "十六夜"
	CASE 1700 TO 1799 
		RETURNF "立待月"
	CASE 1800 TO 1899
		RETURNF "居待月"
	CASE 1900 TO 1999
		RETURNF "寝待月"
	CASE 2000 TO 2299
		RETURNF "二十日月"
	CASE 2300 TO 2599
		RETURNF "下弦の月"
	CASE 2600 TO 2899
		RETURNF "暁月"
	CASE 2900 TO 3000
		RETURNF "三十日月"
ENDSELECT

;;;月の画像表示
@月齢画像
#FUNCTIONS
SELECTCASE 月齢
	CASE 0 TO 187, 2813 TO 3000
		RETURNF "新月"
	CASE 188 TO 562
		RETURNF "三日月"
	CASE 563 TO 937
		RETURNF "上弦の月"
	CASE 938 TO 1312
		RETURNF "十日夜"
	CASE 1313 TO 1687
		RETURNF "満月"
	CASE 1688 TO 2062
		RETURNF "二十日月"
	CASE 2063 TO 2437
		RETURNF "下弦の月"
	CASE 2438 TO 2812
		RETURNF "暁月"
ENDSELECT

;;;ゲームモードを単語で返す
@ゲームモード, ARG = -1
#FUNCTIONS
SIF ARG == -1
	ARG = FLAG:ゲームモード

SELECTCASE ARG
	CASE 0
		RETURNF "通常モード"
	CASE 1
		RETURNF "経営モード"
	CASE 2
		RETURNF "学園モード"
	CASE 3
		RETURNF "SLGモード"
	CASE 7
		RETURNF "新婚モード"
	CASE 8
		RETURNF "段位認定"
	CASE 9
		RETURNF "フリーモード"
ENDSELECT
	

;;;現在の日付を「XX年XX月XX日(X曜日) 祝日(あれば) XX日目」の形式でPRINTする
@日付表示
#FUNCTIONS
#DIMS DYNAMIC 返り値

#DIM DYNAMIC LCOUNT
IF LANGUAGE == "ENG"
	SELECTCASE MONTH
		CASE 1
			返り値 += "January "
		CASE 2
			返り値 += "February "
		CASE 3
			返り値 += "March "
		CASE 4
			返り値 += "April "
		CASE 5
			返り値 += "May "
		CASE 6
			返り値 += "June "
		CASE 7
			返り値 += "July "
		CASE 8
			返り値 += "August "
		CASE 9
			返り値 += "September "
		CASE 10
			返り値 += "October "
		CASE 11
			返り値 += "November "
		CASE 12
			返り値 += "December "
	ENDSELECT

	返り値 += @"{DAYS}, "
	IF YEAR > 0
		返り値 += @"{YEAR}"
	ELSE
		返り値 += @"BC{ABS(YEAR)+1}"
	ENDIF
	返り値 += @"(%DOWDISP(FLAG:曜日)%) "
ELSE
	IF YEAR > 0
		返り値 += @"{YEAR}"
	ELSE
		返り値 += @"BC{ABS(YEAR)+1}"
	ENDIF
	返り値 += @"年{MONTH}月{DAYS}日(%DOW(FLAG:曜日)%) "
ENDIF

IF LANGUAGE == "JP"
	FOR LCOUNT, 0, 5
		SIF HOLIDAY:LCOUNT == ""
			BREAK
		返り値 += @"%HOLIDAY:LCOUNT% "
	NEXT
ENDIF

IF LANGUAGE == "ENG"
	IF ゲームモード() == "学園モード"
		返り値 += @"Day {DAY}"
		SELECTCASE ターン
			CASE "朝"
				返り値 += "(Morning) "
			CASE "昼"
				返り値 += "(Noon) "
			CASE "夜"
				返り値 += "(Evening) "
		ENDSELECT
	ELSE
		返り値 += @"Day {DAY}(\@ ターン == "昼" ? Noon # Evening \@) "
	ENDIF
ELSE
	IF ゲームモード() == "学園モード"
		返り値 += @"{DAY}日目(%ターン%) "
	ELSE
		返り値 += @"{DAY}日目(\@ ターン == "昼" ? 昼 # 夜 \@) "
	ENDIF
ENDIF

RETURNF 返り値

;;;ゲームモードをPRINTする
@ゲームモード表示
#FUNCTIONS

SELECTCASE FLAG:ゲームモード
	CASE 0
		RETURNF "MODE:STANDARD"
	CASE 1
		RETURNF "MODE:STRATEGY"
	CASE 2
		RETURNF "MODE:SCHOOL"
	CASE 7
		RETURNF "MODE:新婚生活"
	;CASE 8
	;	CALL GRADE, FLAG:選択段位, 1
	;	RETURNF ""
	CASE 9
		RETURNF "MODE:PREMIUM FREE"
ENDSELECT

;;;性別の表記を返す
@性別表示, ARG = -1
#FUNCTIONS
SIF ARG == -1
	ARG = TARGET
SIF ARG == -1
	RETURNF 

IF TALENT:ARG:性転換済
	IF LANGUAGE == "ENG"
		SELECTCASE SEX(ARG)
			CASE 1
				RETURNF "(♀→♂)"
			CASE 2
				RETURNF "(♂→♀)"
		ENDSELECT
	ELSE
		SELECTCASE SEX(ARG)
			CASE 1
				RETURNF "(元♀の♂)"
			CASE 2
				RETURNF "(元♂の♀)"
		ENDSELECT
	ENDIF
ELSE
	SELECTCASE SEX(ARG)
		CASE 1
			RETURNF "(♂)"
		CASE 2
			RETURNF "(♀)"
	ENDSELECT
ENDIF

;;;リアルタイムでゲームを始めた日を返す
@ゲーム開始日, ARG
#FUNCTIONS
RETURNF @"{REALTIME:年}年{REALTIME:月}月{REALTIME:日}日"

;;;渡されたSTAINに指定された汚れがあるかを返す関数
@GET_STAIN, ARG, 汚れ:0, 汚れ:1, 汚れ:2, 汚れ:3, 汚れ:4, 汚れ:5, 汚れ:6, 汚れ:7
#FUNCTION
#DIM DYNAMIC LCOUNT
#DIMS DYNAMIC 汚れ, 8
FOR LCOUNT, 0, 8
	IF GETBIT(ARG, LCOUNT)
		SELECTCASE LCOUNT
			CASE 0
				SIF FINDELEMENT(汚れ, "愛液") >= 0
					RETURNF 1
			CASE 1
				SIF FINDELEMENT(汚れ, "先走り") >= 0
					RETURNF 1
			CASE 2
				SIF FINDELEMENT(汚れ, "精液") >= 0
					RETURNF 1
			CASE 3
				SIF FINDELEMENT(汚れ, "アナル") >= 0
					RETURNF 1
			CASE 4
				SIF FINDELEMENT(汚れ, "母乳") >= 0
					RETURNF 1
			CASE 5
				SIF FINDELEMENT(汚れ, "粘液") >= 0
					RETURNF 1
			CASE 6
				SIF FINDELEMENT(汚れ, "破瓜血") >= 0
					RETURNF 1
			CASE 7
				SIF FINDELEMENT(汚れ, "尿") >= 0
					RETURNF 1
		ENDSELECT
	ENDIF
NEXT

RETURNF 0

;;;Digit Separator(桁区切り)関数
;;;大きな数字を扱うとき桁を区切っても使えるようにする
;;;実情はREPLACEの正規表現で数字以外を消してるのでどんな滅茶苦茶な区切りでも使える
@DIG_SEP, ARGS
#FUNCTION
REPLACE ARGS, "[^0-9]", ""

RETURNF TOINT(RESULTS)

;;;数字に3桁区切りコンマを挿入する関数
@TODIGSEP, 数値
#FUNCTIONS
#DIMS DYNAMIC 返り値
#DIM DYNAMIC 数値
SIF 数値 > 999
	返り値 += TODIGSEP(数値/1000)+","

;上記処理を通ってきた場合は下三桁に0補完を行う
IF 返り値 != ""
	RETURNF @"%返り値%\@ 数値%1000 < 100 ? 0 #\@\@ 数値%1000 < 10 ? 0 #\@{数値%1000}"
ELSE
	RETURNF TOSTR(数値%1000)
ENDIF

;;;漢字桁を数字に変換する
@TONUM, 区切り対象
#FUNCTION
#DIM DYNAMIC 返り値
#DIMS DYNAMIC 区切り対象
#DIMS DYNAMIC エラー通知用
;万が一同じ桁が2回使われたとき用に3取ってみる
#DIMS DYNAMIC 表示用, 3
エラー通知用 = %区切り対象%

IF STRFIND(区切り対象, "京") > 0
	SPLIT 区切り対象, "京", 表示用
	返り値 += TOINT(表示用)*DIG_SEP("10,000,000,000,000,000")
	区切り対象 = %表示用:1%
ENDIF
IF STRFIND(区切り対象, "兆") > 0
	SPLIT 区切り対象, "兆", 表示用
	返り値 += TOINT(表示用)*DIG_SEP("1,000,000,000,000")
	区切り対象 = %表示用:1%
ENDIF
IF STRFIND(区切り対象, "億") > 0
	SPLIT 区切り対象, "億", 表示用
	返り値 += TOINT(表示用)*DIG_SEP("100,000,000")
	区切り対象 = %表示用:1%
ENDIF
IF STRFIND(区切り対象, "万") > 0
	SPLIT 区切り対象, "万", 表示用
	返り値 += TOINT(表示用)*DIG_SEP("10,000")
	区切り対象 = %表示用:1%
ENDIF

;#;SIF ISNUMERIC(区切り対象)
;#; THROW 「%エラー通知用%」は正常に変換できません

返り値 += DIG_SEP(区切り対象)

RETURNF 返り値

;;;数字を漢字桁に変換する 頭の悪い関数名
@TO漢字, 変換対象
#FUNCTIONS
#DIMS DYNAMIC 返り値
#DIM DYNAMIC 変換対象
SIF 変換対象 == 0
	RETURNF "0"

IF 変換対象 >= DIG_SEP("10,000,000,000,000,000")
	返り値 += @"%TOSTR(変換対象/DIG_SEP("10,000,000,000,000,000"))%京"
	変換対象 %= DIG_SEP("10,000,000,000,000,000")
ENDIF
IF 変換対象 >= DIG_SEP("1,000,000,000,000")
	返り値 += @"%TOSTR(変換対象/DIG_SEP("1,000,000,000,000"))%兆"
	変換対象 %= DIG_SEP("1,000,000,000,000")
ENDIF
IF 変換対象 >= DIG_SEP("100,000,000")
	返り値 += @"%TOSTR(変換対象/DIG_SEP("100,000,000"))%億"
	変換対象 %= DIG_SEP("100,000,000")
ENDIF
IF 変換対象 >= DIG_SEP("10,000")
	返り値 += @"%TOSTR(変換対象/DIG_SEP("10,000"))%万"
	変換対象 %= DIG_SEP("10,000")
ENDIF
SIF 変換対象 > 0
	返り値 += TOSTR(変換対象)

RETURNF 返り値

;;;渡された数字をオプションに従ってTODIGSEPかTO漢字通して返す関数
@TOOPTIONINT, 変換対象
#FUNCTIONS
#DIM DYNAMIC 変換対象

SELECTCASE 数値表示設定
	CASE "3桁区切り"
		RETURNF @"\@ SIGN(変換対象) == -1 ? - #\@%TODIGSEP(ABS(変換対象))%"
	CASE "漢字桁表示"
		RETURNF @"\@ SIGN(変換対象) == -1 ? - #\@%TO漢字(ABS(変換対象))%"
	CASEELSE
		RETURNF @"\@ SIGN(変換対象) == -1 ? - #\@%TOSTR(ABS(変換対象))%"
ENDSELECT

;;;DIVIDE10 10で割って小数点付ける関数 マイナスにも対応 ほぼ気温表示用
@DIV10, ARG
#FUNCTIONS
RETURNF @"{ARG/10}.{ABS(ARG%10)}"

;;;DIVIDE100 100で割って小数点付ける関数 ほぼ月齢表示用
@DIV100, ARG
#FUNCTIONS
RETURNF @"{ARG/100}.\@ABS(ARG%100) < 10 ? 0 # \@{ABS(ARG%100)}"

;;;性別不明キャラの性別選択関数
;;;TALENT:性別が0のキャラは性別不明とする
@性別選択, ARG
IF TALENT:ARG:性別 == 0
	;SKIPDISP中ならランダムにしてみる
	SIF ISSKIP()
		GOTOFORM GENDER_{RAND(1, 3)}
	PRINTFORML %CHARANAMEF(ARG)%の性別を選択してください
	PRINTL [1] - 男の子
	PRINTL [2] - 女の子
	CALL INPUTF, 1, 2
	SELECTCASE RESULT
		CASE 1
			$GENDER_1
			TALENT:ARG:性別 = 1
			TALENT:ARG:童貞 = 1
		CASE 2
			$GENDER_2
			TALENT:ARG:性別 = 2
			TALENT:ARG:処女 = 1
			TALENT:ARG:バストサイズ = 1
	ENDSELECT
ENDIF

RETURN

;;;ISTALENT 指定したキャラに指定した素質がある場合は素質名をPRINTする
;;;括弧を指定可能 デフォルトは[]
@ISTALENT, キャラ, 素質名, 括弧
#DIM DYNAMIC キャラ
#DIMS DYNAMIC 素質名
#DIMS DYNAMIC 括弧
SIF キャラ == -1
	キャラ = TARGET
SIF キャラ == -1
	RETURN

IF GETNUM(TALENT, 素質名) == -1
	;#;THROW 素質「%素質名%」は存在しないか、表記ゆれです
	RETURN
ENDIF

IF TALENT:キャラ:素質名
	IF 括弧 != ""
		PRINTFORM %CHARATU(括弧, 0)%%素質名%%CHARATU(括弧, 1)%
	ELSE
		PRINTFORM [%素質名%]
	ENDIF
ENDIF

RETURN

;;;ISTALENTの式中関数版
@ISTALENTF, キャラ, 素質名, 括弧
#FUNCTIONS
#DIM DYNAMIC キャラ = -1
#DIMS DYNAMIC 素質名
#DIMS DYNAMIC 括弧

SIF キャラ == -1
	キャラ = TARGET
SIF キャラ == -1
	RETURNF ""

IF GETNUM(TALENT, 素質名) == -1
	;#;THROW 素質「%素質名%」は存在しないか、表記ゆれです
	RETURNF ""
ENDIF

IF TALENT:キャラ:素質名
	IF 括弧 != ""
		RETURNF @"%CHARATU(括弧, 0)%%素質名%%CHARATU(括弧, 1)%"
	ELSE
		RETURNF @"[%素質名%]"
	ENDIF
ELSE
	RETURNF ""
ENDIF

;;;100分率で(引数)%で1を返す
@RANDPER, 確率
#FUNCTION
#DIM DYNAMIC 確率

IF RAND(1, 101) <= 確率
	RETURNF 1
ELSE
	RETURNF 0
ENDIF

;;;色付きでPRINTしてからRESETCOLORする 引数はBYNAME
@PRINTCOLOR, ARGS, 色名
#DIMS DYNAMIC 色名

IF COLOR_FROMNAME(色名) == -1
	IF ISNUMERIC(色名)
		SETCOLOR TOINT(色名)
	ELSE
		RESETCOLOR
	ENDIF
ELSE
	SETCOLOR COLOR_FROMNAME(色名)
ENDIF

PRINTFORM %ARGS%
RESETCOLOR

;;;上記処理を改行する
@PRINTCOLORL, ARGS, 色名
#DIMS DYNAMIC 色名

CALL PRINTCOLOR, ARGS, 色名
PRINTL

;;;スライムor溶ける快
@ISSLIME, ARG
#FUNCTION

SIF !INRANGE(ARG, 0, CHARANUM-1)
	RETURNF 0

SIF TALENT:ARG:スライム || TALENT:ARG:溶ける快
	RETURNF 1
SIF CSTR:ARG:種族 == "スライム"
	RETURNF 1
RETURNF 0

;;;処女or再生処女
@処女膜, ARG
#FUNCTION

SIF TALENT:ARG:処女 || TALENT:ARG:再生処女
	RETURNF 1
RETURNF 0

;;;バストサイズ
@バストサイズ, ARG
#FUNCTIONS
#DIMS DYNAMIC プラス値

SELECTCASE ARG
	CASE 1
		RETURNF "絶壁"
	CASE 2
		RETURNF "貧乳"
	CASE 3
		RETURNF "並乳"
	CASE 4
		RETURNF "巨乳"
	CASE 5
		RETURNF "豊乳"
	CASE 6
		RETURNF "爆乳"
	CASE IS >= 7
		プラス値 = "爆乳+"
		プラス値 += TOSTR(ARG-6)
		RETURNF プラス値
ENDSELECT

;;;体格
@体格, ARG
#FUNCTIONS

SELECTCASE ARG
	CASE 1
		RETURNF "幼児"
	CASE 2
		RETURNF "小柄"
	CASE 3
		RETURNF "普通"
	CASE 4
		RETURNF "長身"
ENDSELECT

;;;調教可能か
@調教可能, 対象
#FUNCTION
#DIM DYNAMIC 対象

SIF 対象 == MASTER
	RETURNF 0
SIF CHECK_CHILD_CARE(対象)
	RETURNF 0
SIF CFLAG:対象:使用不可
	RETURNF 0
SIF CFLAG:対象:キャラロスト
	RETURNF 0

RETURNF 1

;;;助手可能か
@助手可能, 対象
#FUNCTION
#DIM DYNAMIC 対象

SIF 対象 == MASTER
	RETURNF 0
SIF CHECK_CHILD_CARE(対象)
	RETURNF 0
SIF CFLAG:対象:使用不可
	RETURNF 0
SIF !CFLAG:対象:助手可能 && !TALENT:対象:アニマル
	RETURNF 0
SIF CFLAG:対象:キャラロスト
	RETURNF 0

RETURNF 1

;;;売却可能か
@売却可能, 対象
#FUNCTION
#DIM DYNAMIC 対象

SIF 対象 == MASTER
	RETURNF 0
SIF CHECK_CHILD_CARE(対象)
	RETURNF 0
SIF !CFLAG:対象:売却可能
	RETURNF 0
SIF CFLAG:対象:売却不可
	RETURNF 0
SIF CFLAG:対象:キャラロスト
	RETURNF 0
;魔法の効果発動中のキャラは除外
SIF ISENCHANT(対象)
	RETURNF 0
SIF TALENT:対象:アニマル
	RETURNF 0

RETURNF 1

;;;第一引数のキャラの第二引数のキャラに対するRELATIONを返す
@相性値, 対象, 相手
#FUNCTION
#DIM DYNAMIC 対象
#DIM DYNAMIC 相手
#DIM DYNAMIC 補正値
#DIM DYNAMIC 返り値

SIF TALENT:対象:犬嫌い && TALENT:相手:犬
	補正値 -= 30
SIF TALENT:対象:猫嫌い && TALENT:相手:猫
	補正値 -= 30
SIF ISHATERACE(対象, 相手)
	補正値 -= 30

;ネクロマンサーと霊感と孔雀の瞳なら中の人が見破れる
IF CFLAG:相手:憑依 >= 0
	IF TALENT:対象:霊感 || TALENT:対象:ネクロマンサー || TALENT:対象:孔雀の瞳
		IF RELATION:対象:(NO:相手) == 0
			返り値 = 100+補正値
		ELSE
			返り値 = RELATION:対象:(NO:相手)+補正値
		ENDIF
	ELSE
		IF RELATION:対象:(CFLAG:相手:憑依) == 0
			返り値 = 100+補正値
		ELSE
			返り値 = RELATION:対象:(CFLAG:相手:憑依)+補正値
		ENDIF
	ENDIF
ELSE
	IF RELATION:対象:(NO:相手) == 0
		返り値 = 100+補正値
	ELSE
		返り値 = RELATION:対象:(NO:相手)+補正値
	ENDIF
ENDIF

;システムの都合上1未満にはならない
IF 返り値 < 1
	RETURNF 1
ELSE
	RETURNF 返り値
ENDIF

@相性加算, 対象, 相手, 上昇値, 上限
#DIM DYNAMIC 対象
#DIM DYNAMIC 相手
#DIM DYNAMIC 上昇値
#DIM DYNAMIC 上限

SIF RELATION:対象:NOF(相手) == 0
	RELATION:対象:NOF(相手) = 100

;上昇処理なら上限値を適用 減少処理なら下限値を適用
IF SIGN(上昇値) == 1
	;MASTERとネクロマンサーと霊感と孔雀の瞳なら中の人が見破れる
	IF CFLAG:相手:憑依 >= 0
		IF 対象 == MASTER || TALENT:対象:霊感 || TALENT:対象:ネクロマンサー || TALENT:対象:孔雀の瞳
			GOTO NOTGHOSTUP
		ELSE
			;上限突っ切ってたら処理しない
			SIF 上限 && RELATION:対象:(CFLAG:相手:憑依) > 上限
				RETURN
			RELATION:対象:(CFLAG:相手:憑依) += 上昇値
			SIF 上限 && RELATION:対象:(CFLAG:相手:憑依) > 上限
				RELATION:対象:(CFLAG:相手:憑依) = 上限
		ENDIF
	ELSE
		$NOTGHOSTUP
		;上限突っ切ってたら処理しない
		SIF 上限 && RELATION:対象:NOF(相手) > 上限
			RETURN
		RELATION:対象:NOF(相手) += 上昇値
		SIF 上限 && RELATION:対象:NOF(相手) > 上限
			RELATION:対象:NOF(相手) = 上限
	ENDIF
ELSEIF SIGN(上昇値) == -1
	IF CFLAG:相手:憑依 >= 0
		IF 対象 == MASTER || TALENT:対象:霊感 || TALENT:対象:ネクロマンサー || TALENT:対象:孔雀の瞳
			GOTO NOTGHOSTDOWN
		ELSE
			RELATION:対象:(CFLAG:相手:憑依) += 上昇値
			SIF 上限 && RELATION:対象:(CFLAG:相手:憑依) < 上限
				RELATION:対象:(CFLAG:相手:憑依) = 上限
			;システムの都合上1未満にはならない
			SIF RELATION:対象:(CFLAG:相手:憑依) < 1
				RELATION:対象:(CFLAG:相手:憑依) = 1
		ENDIF
	ELSE
		$NOTGHOSTDOWN
		RELATION:対象:NOF(相手) += 上昇値
		SIF 上限 && RELATION:対象:NOF(相手) < 上限
			RELATION:対象:NOF(相手) = 上限
		;システムの都合上1未満にはならない
		SIF RELATION:対象:NOF(相手) < 1
			RELATION:対象:NOF(相手) = 1
	ENDIF
ENDIF

;;;DO
;;;	INPUT
;;;LOOP LOOPRES(XX, XX, XX)
;;;を一行でやる関数 単純な選択肢などに使える
@INPUTF, 数値:0 = __INT_MAX__, 数値:1 = __INT_MAX__,数値:2 = __INT_MAX__,数値:3 = __INT_MAX__,数値:4 = __INT_MAX__,数値:5 = __INT_MAX__,数値:6 = __INT_MAX__,数値:7 = __INT_MAX__,数値:8 = __INT_MAX__,数値:9 = __INT_MAX__,
#DIM DYNAMIC 数値, 10
DO
	INPUT
LOOP LOOPRES(数値:0, 数値:1, 数値:2, 数値:3, 数値:4, 数値:5, 数値:6, 数値:7, 数値:8, 数値:9)

RETURN RESULT

@撮影中, ARG
#FUNCTION

SIF TEQUIP:ビデオカメラ || TEQUIP:ライブ配信
	RETURNF 1
SIF TEQUIP:羞恥プレイ && アイテム改造:大鏡 == "マジックミラー"
	RETURNF 1

RETURNF 0

;;;引数と同じ数だけの半角スペースを返す
;;;通す際はSTRLENS(Uじゃない)で
@SPACES, 文字数
#FUNCTIONS
#DIM DYNAMIC 文字数
#DIM DYNAMIC LCOUNT
#DIMS DYNAMIC SPACE

FOR LCOUNT, 0, 文字数
	SPACE += " "
NEXT

RETURNF SPACE

;;;上記SPACESとSTRLENSを組み合わせたもの
@SPACESLENS, 文字列
#FUNCTIONS
#DIMS DYNAMIC 文字列
#DIM DYNAMIC LCOUNT
#DIMS DYNAMIC SPACE

FOR LCOUNT, 0, STRLENS(文字列)
	SPACE += " "
NEXT

RETURNF SPACE

;;;サキュバスorインキュバス
@淫魔, 対象
#FUNCTION
#DIM DYNAMIC 対象

SIF TALENT:対象:サキュバス || TALENT:対象:インキュバス
	RETURNF 1

RETURNF 0

;;;ループやRESTART時に同じ物を表示しないようにCLEARLINEする関数
@LOOP_CLEARLINE
SIF VARLINE > 0
	CLEARLINE LINECOUNT-VARLINE
VARLINE = LINECOUNT
RETURN RESULT

;;;英数字→漢数字に変換する式中関数 現状0～15まで
@CONV_NO(ARG)
#FUNCTIONS
SELECTCASE ARG
	CASE 0
		RETURNF "零"
	CASE 1
		RETURNF "一"
	CASE 2
		RETURNF "二"
	CASE 3
		RETURNF "三"
	CASE 4
		RETURNF "四"
	CASE 5
		RETURNF "五"
	CASE 6
		RETURNF "六"
	CASE 7
		RETURNF "七"
	CASE 8
		RETURNF "八"
	CASE 9
		RETURNF "九"
	CASE 10
		RETURNF "十"
	CASE 11
		RETURNF "十一"
	CASE 12
		RETURNF "十二"
	CASE 13
		RETURNF "十三"
	CASE 14
		RETURNF "十四"
	CASE 15
		RETURNF "十五"
	CASEELSE
		RETURNF ""
ENDSELECT

;;;対象がその種族を嫌っているかの判定
@特定種族嫌悪, 対象, 対象種族
#FUNCTION
#DIM DYNAMIC 対象
#DIMS DYNAMIC 対象種族
#DIMS DYNAMIC 分割用, 20
SIF 対象 < 0
	RETURNF 0

SPLIT CSTR:対象:種族嫌悪, "/", 分割用

SIF FINDELEMENT(分割用, 対象種族, 0, VARSIZE("分割用"), 1) >= 0
	RETURNF 1

RETURNF 0

;;;対象が相手の種族を嫌っているかどうかの判定
@ISHATERACE, 対象, 相手
#FUNCTION
#DIM DYNAMIC 対象
#DIM DYNAMIC 相手
SIF 対象 < 0 || 相手 < 0
	RETURNF 0

SIF 特定種族嫌悪(対象, CSTR:相手:種族)
	RETURNF 1

RETURNF 0

;;;条件がtrueだった場合は文字列を、falseならPRINTPLAINで文字数分の空白を描画する
@PRINTSPACE, 条件, 文字列
#DIM DYNAMIC 条件
#DIMS DYNAMIC 文字列
IF 条件
	PRINTFORM %文字列%
ELSE
	PRINTPLAINFORM %SPACESLENS(文字列)%
ENDIF

;;;条件がtrueだった場合は文字列を、falseなら文字数分の空白を返す
@RETURNSPACE, 条件, 文字列
#FUNCTIONS
#DIM DYNAMIC 条件
#DIMS DYNAMIC 文字列
IF 条件
	RETURNF 文字列
ELSE
	RETURNF SPACESLENS(文字列)
ENDIF


;;;尿道に道具使ってるかどうかの式中関数
@Ｕ使用中, ARG
#FUNCTION

SIF ARG == -1
	ARG = TARGET

SIF TEQUIP:ARG:尿道カテーテル
	RETURNF 1
SIF TEQUIP:ARG:尿道ポッキー
	RETURNF 1
SIF TEQUIP:ARG:尿道スライム
	RETURNF 1

;;;引数のフォーマットは「イベント内容」
@プレイログ記録, 内容
#DIMS DYNAMIC 内容

ARRAYSHIFT プレイログ, 1, ""
;年月日を自動で付ける
プレイログ:0 = {YEAR}年{MONTH, 2}月{DAYS, 2}日\@ ターン == "昼" ? 昼 # 夜 \@ %内容%

;;;引数のフォーマットは「イベント/入出金」
;;;一応TOINTで解釈できない引数渡されたら記録しないorTHROW
@現金出納帳記録, 内容
#DIMS DYNAMIC 内容
#DIMS DYNAMIC SPLITVAR, 2

SPLIT 内容, "/", SPLITVAR
IF !ISNUMERIC(SPLITVAR:1)
	;#; THROW 現金出納帳記録で数字解釈できない引数が渡されました
	RETURN
ENDIF
;ついでに0でも記録しない
SIF TOINT(SPLITVAR:1) == 0
	RETURN

ARRAYSHIFT 現金出納帳, 1, ""
;年月日と所持金を自動で付ける
現金出納帳:0 = {YEAR}-{MONTH}-{DAYS}-%内容%/{MONEY}

;;;LINEISEMPTYとPRINTLをやる関数
@NEWLINE
SIF !LINEISEMPTY()
	PRINTL 

;;;RESETDATAとCLEARMEMORYを行う
@RESET_DATA
RESETDATA
CALLF メモリ解放, "RESET_DATA"

;;;DEBUGPRINTにメッセージを添えてCLEARMEMORYする関数
@メモリ解放, ARGS
#FUNCTION
SIF !SP
	DEBUGPRINTFORML メモリ解放:%ARGS%:{CLEARMEMORY()/1024/1024}MB

;;;カレンダーを作る 引数省略でYEAR,MONTH,DAYSを参照する
@カレンダー生成, 年 = -100200400, 月, 日
#DIM DYNAMIC 年
#DIM DYNAMIC 月
#DIM DYNAMIC 日
#DIM DYNAMIC LCOUNT
#DIM DYNAMIC LCOUNT2
#DIM DYNAMIC LINE
#DIM DYNAMIC CELL

IF 年 == -100200400
	年 = YEAR
	月 = MONTH
	日 = DAYS
ENDIF

GDISPOSE 0
GCREATE 0, 730, 775

GCLEAR 0, COLOR_FROMNAME("white")+0xFF000000

GSETFONT 0, "ＭＳ 明朝", 100
GSETBRUSH 0, 0xFF000000
GDRAWTEXT 0, @"{年}年 {月}月", 100, 10

FOR LCOUNT, 1, 32
	SIF !EXIST_DAY(年, 月, LCOUNT)
		BREAK
	GSETFONT 0, "ＭＳ ゴシック", 50
	CELL = ZELLER(年, 月, LCOUNT)-1
	SIF CELL == -1
		CELL = 6
	SIF LCOUNT != 1 && DOW(ZELLER(年, 月, LCOUNT)) == "日"
		LINE++
	SELECTCASE DOW(ZELLER(年, 月, LCOUNT))
		CASE "土"
			GSETBRUSH 0, 0xFF0000FF
		CASE "日"
			GSETBRUSH 0, 0xFFFF0000
		CASEELSE
			IF ゲームモード() == "学園モード" && (夏休み(月, LCOUNT) || 冬休み(月, LCOUNT) || 春休み(月, LCOUNT))
				GSETBRUSH 0, 0xFFFF0000
			ELSE
				GSETBRUSH 0, 0xFF000000
			ENDIF
	ENDSELECT
	GDRAWTEXT 0, @"%TOSTR(LCOUNT), 2%", CELL*105+25, LINE*105+175
	IF 年 == YEAR && 月 == MONTH && LCOUNT == DAYS
		GSETFONT 0, "ＭＳ ゴシック", 120
		GDRAWTEXT 0, "○", CELL*105-10, LINE*105+140
	ENDIF
NEXT

FOR LCOUNT, 0, GWIDTH(0)
	FOR LCOUNT2, 145, GHEIGHT(0)
		SIF INRANGE(LCOUNT%105, 100, 104)
			GSETCOLOR 0, 0xFF000000, LCOUNT, LCOUNT2
		SIF INRANGE((LCOUNT2-45)%105, 100, 104)
			GSETCOLOR 0, 0xFF000000, LCOUNT, LCOUNT2
	NEXT
NEXT

SPRITECREATE "カレンダー", 0

;;;画像名をHTMLタグに整形するだけ
@IMGTOTAG, ARGS, HEIGHT, WIDTH
#FUNCTIONS
#DIM DYNAMIC HEIGHT
#DIM DYNAMIC WIDTH
IF HEIGHT
	RETURNF @"<img src='%ARGS%' srcb='' height='{HEIGHT}' width='{WIDTH}'>"
ELSE
	RETURNF @"<img src='%ARGS%' srcb=''>"
ENDIF

;;;グラフィカルなBAR画像を作成
@GBAR, VAL, MAXVAL, LENGTH, COLOR, BGCOLOR, TEXT, TEXTCOLOR
#FUNCTIONS
#DIM DYNAMIC VAL
#DIM DYNAMIC MAXVAL
#DIM DYNAMIC LENGTH
#DIM DYNAMIC GID = 0
#DIMS DYNAMIC COLOR
#DIMS DYNAMIC BGCOLOR
#DIM DYNAMIC WIDTH
#DIM DYNAMIC HEIGHT
#DIM DYNAMIC PX
#DIMS DYNAMIC TEXT
#DIMS DYNAMIC TEXTCOLOR

DO
	SIF !GCREATED(GID)
		BREAK
	GID++
	;SIF GID >= 8192
	;	THROW GID全部埋まってる
LOOP 1

;フォントサイズと1行の高さが同じだと繋がってしまうので少し減らす
IF GETCONFIG("フォントサイズ") == GETCONFIG("一行の高さ")
	GCREATE GID, GETCONFIG("フォントサイズ")*LENGTH, GETCONFIG("フォントサイズ")-4
ELSE
	GCREATE GID, GETCONFIG("フォントサイズ")*LENGTH, GETCONFIG("フォントサイズ")
ENDIF

IF ISNUMERIC(BGCOLOR)
	GCLEAR GID, TOINT(BGCOLOR)+0xFF000000
ELSE
	SIF COLOR_FROMNAME(BGCOLOR) < 0
		THROW %BGCOLOR%は色名じゃない
	GCLEAR GID, COLOR_FROMNAME(BGCOLOR)+0xFF000000
ENDIF

;VALとMAXVALとLENGTHからどのピクセルまで塗るか計算する
;VAL >= MAXVALなら全部
IF VAL >= MAXVAL
	PX = GWIDTH(GID)
ELSE
	PX = LENGTH*10000*VAL*GETCONFIG("フォントサイズ")/MAXVAL/10000
ENDIF

;EMでGCLEAR拡張されてたので使ってみる
IF ISNUMERIC(COLOR)
	GCLEAR GID, TOINT(COLOR)+0xFF000000, 0, 0, PX, GHEIGHT(GID)
	;DEBUGPRINTFORML {GID} %COLOR% {PX}
ELSE
	SIF COLOR_FROMNAME(COLOR) < 0
		THROW %COLOR%は色名じゃない
	GCLEAR GID, COLOR_FROMNAME(COLOR)+0xFF000000, 0, 0, PX, GHEIGHT(GID)
	;DEBUGPRINTFORML {GID} %COLOR% {PX}
ENDIF

[SKIPSTART]
FOR WIDTH, 0, GWIDTH(GID)
	FOR HEIGHT, 0, GHEIGHT(GID)
		;まさかCOLORとBGCOLORの書式を統一しないやつはいないだろう
		IF ISNUMERIC(COLOR)
			SIF PX > WIDTH
				GSETCOLOR GID, TOINT(COLOR)+0xFF000000, WIDTH, HEIGHT
		ELSE
			SIF PX > WIDTH
				GSETCOLOR GID, COLOR_FROMNAME(COLOR)+0xFF000000, WIDTH, HEIGHT
		ENDIF
	NEXT
NEXT
[SKIPEND]

IF TEXT != ""
	IF TEXTCOLOR != ""
		IF ISNUMERIC(TEXTCOLOR)
			GSETBRUSH GID, TOINT(TEXTCOLOR)+0xFF000000
		ELSE
			GSETBRUSH GID, COLOR_FROMNAME(TEXTCOLOR)+0xFF000000
		ENDIF
	ELSE
		GSETBRUSH GID, GETCOLOR()+0xFF000000
	ENDIF
	GSETPEN GID, 0, 0
	GSETFONT GID, "ＭＳ ゴシック", GHEIGHT(GID)
	GDRAWTEXT GID, TEXT
ENDIF

SPRITEDISPOSE @"GBAR{GID}"
SPRITECREATE @"GBAR{GID}", GID, 0, 0, GWIDTH(GID), GHEIGHT(GID)

GIDDEL:GID = 1

RETURNF @"GBAR{GID}"

;;;体力、気力、魔力をGBARで整形したタグを返す
@BASEBAR, ARGS, ARG = -1, ARG:1 = 16
#FUNCTIONS
#DIMS DYNAMIC COLOR

SIF ARG == -1
	ARG = TARGET

SELECTCASE ARGS
	CASE "体力"
		RETURNF GBAR(BASE:ARG:体力, MAXBASE:ARG:体力, ARG:1, BARCOLOR:体力, "gray", @"{BASE:ARG:体力}/{MAXBASE:ARG:体力}", "black")
	CASE "気力"
		RETURNF GBAR(BASE:ARG:気力, MAXBASE:ARG:気力, ARG:1, BARCOLOR:気力, "gray", @"{BASE:ARG:気力}/{MAXBASE:ARG:気力}", "black")
	CASE "魔力"
		RETURNF GBAR(BASE:ARG:魔力, MAXBASE:ARG:魔力, ARG:1, BARCOLOR:魔力, "gray", @"{BASE:ARG:魔力}/{MAXBASE:ARG:魔力}", "black")
	CASE "射精"
		RETURNF GBAR(BASE:ARG:射精, MAXBASE:ARG:射精, ARG:1, BARCOLOR:射精, "gray", @"{BASE:ARG:射精}/{MAXBASE:ARG:射精}", "black")
	CASE "母乳"
		RETURNF GBAR(BASE:ARG:母乳, MAXBASE:ARG:母乳, ARG:1, BARCOLOR:母乳, "gray", @"{BASE:ARG:母乳}/{MAXBASE:ARG:母乳}", "black")
	CASE "触手射精"
		RETURNF GBAR(BASE:ARG:触手射精, MAXBASE:ARG:触手射精, ARG:1, BARCOLOR:射精, "gray", @"{BASE:ARG:触手射精}/{MAXBASE:ARG:触手射精}", "black")
	CASE "ドラゴン射精"
		RETURNF GBAR(BASE:ARG:ドラゴン射精, MAXBASE:ARG:ドラゴン射精, ARG:1, BARCOLOR:射精, "gray", @"{BASE:ARG:ドラゴン射精}/{MAXBASE:ARG:ドラゴン射精}", "black")
	CASE "モチベ", "モチベーション"
		SELECTCASE CFLAG:ARG:モチベーション
			CASE 1 TO 9
				COLOR = gray
			CASE 10 TO 39
				COLOR = yellow
			CASE 40 TO 60
				COLOR = silver
			CASE 61 TO 90
				COLOR = cyan
			CASE 91 TO 100
				COLOR = lime
		ENDSELECT
		RETURNF GBAR(CFLAG:ARG:モチベーション, 100, ARG:1, COLOR, "gray", @"{CFLAG:ARG:モチベーション}/100", "black")
	CASE "ストレス値", "ストレス"
		CFLAG:ARG:ストレス値 = LIMIT(CFLAG:ARG:ストレス値, 0, 999)
		SELECTCASE CFLAG:ARG:ストレス値
			CASE 0
				COLOR = silver
			CASE 1 TO 99
				COLOR = lime
			CASE 100 TO 299
				COLOR = yellow
			CASE 300 TO 499
				COLOR = red
			CASE IS >= 500
				COLOR = darkred
		ENDSELECT
		RETURNF GBAR(CFLAG:ARG:ストレス値, 999, ARG:1, COLOR, "gray", @"{CFLAG:ARG:ストレス値}/999", "black")
	CASE "リビドー"
		RETURNF GBAR(BASE:ARG:リビドー, 10000, ARG:1, BARCOLOR:リビドー, "gray", @"{BASE:ARG:リビドー}/10000", "black")
ENDSELECT

;;;削除フラグ立ってるGIDを全部DISPOSEする
@GIDDEL
#DIM DYNAMIC LCOUNT
FOR LCOUNT, 0, VARSIZE("GIDDEL")
	SIF GIDDEL:LCOUNT
		GDISPOSE LCOUNT
	GIDDEL:LCOUNT = 0
NEXT

;ついでにスプライトも消す
SPRITEDISPOSEALL 0


@外出可能な服装, 対象
#FUNCTION
#DIM DYNAMIC 対象
#DIM DYNAMIC LCOUNT

;服装がCSVと一致していれば外出できる
IF EXISTCSV(NO:対象)
	FOR LCOUNT, GETNUM(CSTR, "上半身上着"), GETNUM(CSTR, "下半身下着")+1
		SIF CSVCSTR(NO:対象, LCOUNT) != CSTR:対象:LCOUNT
			BREAK
		SIF LCOUNT == GETNUM(CSTR, "下半身下着")
			RETURNF 1
	NEXT
ENDIF

;全身上着着ていない
IF !TEQUIP:対象:全身上着
	;上半身と下半身も着ていない
	SIF !TEQUIP:対象:上半身上着 || !TEQUIP:対象:下半身上着
		RETURNF 0
	RETURNF 1
;全身上着は着ている
ELSE
	;が服として機能していない
	IF CFLAG:対象:着衣併用 == 1
		;上半身と下半身も着ていない
		SIF !TEQUIP:対象:上半身上着 || !TEQUIP:対象:下半身上着
			RETURNF 0
		RETURNF 1
	ELSE
		RETURNF 1
	ENDIF
ENDIF

[SKIPSTART]
@キャラ死亡, 対象
#DIM DYNAMIC 対象
CFLAG:対象:死亡 = 1
FINDELEMENT 死体, 0, 1, 1000
SAVECHARA @"死体_{RESULT}_{データID}", @"%NAME:対象%の死体", 対象
死体:RESULT = 1
CALL プレイログ記録, @"%NAME:対象%が死亡"
CALL CLEAR_CHARA, 対象
TARGET = -1
[SKIPEND]

;;;完全一致のFINDELEMENT簡略版 文字列限定
@FINDELEMENTF, 変数, 検索文字列
#FUNCTION
#DIMS REF 変数
#DIMS DYNAMIC 検索文字列

RETURNF FINDELEMENT(変数, 検索文字列, 0, VARSIZE("変数"), 1)

;;;難易度に応じた色を返す
@難易度色, ARG = -2
#FUNCTIONS
SIF ARG == -2
	ARG = FLAG:難易度

SELECTCASE ARG
	CASE -1
		RETURNF "lime"
	CASE 1
		RETURNF "deepskyblue"
	CASE 2
		RETURNF "yellow"
	CASE 3
		RETURNF "coral"
	CASE 4
		RETURNF "violet"
ENDSELECT

;;;主人対象助手のいずれかが魔術師
@詠唱可能
#FUNCTION

SIF TALENT:MASTER:魔法使い
	RETURNF 1
SIF TARGET > 0 && TALENT:魔法使い
	RETURNF 1
SIF ASSI > 0 && TALENT:ASSI:魔法使い
	RETURNF 1

RETURNF 0

;;;入出金はこの関数で行う
@PAYMENT, 金額, 明細
#DIM DYNAMIC 金額
#DIMS DYNAMIC 明細

MONEY += 金額

CALL 現金出納帳記録, @"%明細%/{金額}"

;;;主人か助手が買い物上手持ってるか
@値引き可能
#FUNCTION

SIF TALENT:MASTER:買い物上手 || (ASSI > 0 && TALENT:ASSI:買い物上手)
	RETURNF 1

;;;変化可能なキャラが居るかどうか
@変化可能
#FUNCTION
#DIM DYNAMIC LCOUNT

FOR LCOUNT, 1, CHARANUM
	SIF TALENT:LCOUNT:変化 && !CFLAG:LCOUNT:キャラロスト
		RETURNF 1
NEXT

RETURNF 0

;;;CSV番号を変えてもいいようにNOはこの関数を通す
@NOF(対象)
#FUNCTION
#DIM DYNAMIC 対象
#DIM DYNAMIC LCOUNT
#DIM 保存済み
#DIMS 名前保存用, 10000

;重いので今のところは使わない
RETURNF NO:対象

SIF CFLAG:対象:CSV無し
	RETURNF NO:対象
SIF NAME:対象 == ""
	RETURNF 0

IF !保存済み
	FOR LCOUNT, 0, 10000
		SIF EXISTCSV(LCOUNT)
			名前保存用:LCOUNT = %CSVNAME(LCOUNT)%
	NEXT
	保存済み = 1
ENDIF

IF FINDELEMENT(名前保存用, ESCAPE(NAME:対象)) < 0
	;#;THROW %NAME:対象%のCSVが存在しません
	RETURNF NO:対象
ENDIF

RETURNF FINDELEMENT(名前保存用, ESCAPE(NAME:対象))

;趣氏作
@MOD適用判定, 対象キャラ, MOD名
#FUNCTION
#DIM DYNAMIC 対象キャラ
#DIMS DYNAMIC MOD名

STRCOUNT CSTR:対象キャラ:適用MOD , @"\\[MOD:%MOD名%\\]"
IF RESULT != 0
	RETURNF 1
ELSE
	RETURNF 0
ENDIF

;RPS(RePlace Space) 名前の空白をハイフンに置換して返す
@RPS, ARGS
#FUNCTIONS

RETURNF REPLACE(ARGS, (" "), "_")

@父親取得, 対象
#FUNCTION
#DIM DYNAMIC LCOUNT
#DIM DYNAMIC 対象

SIF !CFLAG:対象:血縁コード
	RETURNF -1

IF NOF(対象) > 10000
	RETURNF CFLAG:対象:血縁コード/100000
ELSE
	SIF CFLAG:対象:続柄 >= 1000
		RETURNF -1
	FOR LCOUNT, 1, 10000
		IF EXISTCSV(LCOUNT) && CSVCFLAG(LCOUNT, GETNUM(CFLAG, "血縁コード")) == CFLAG:対象:血縁コード
			SIF LCOUNT != NOF(対象) && CSVCFLAG(LCOUNT, GETNUM(CFLAG, "続柄")) == 1000
				RETURNF LCOUNT
		ENDIF
	NEXT
ENDIF

RETURNF -1

@母親取得, 対象
#FUNCTION
#DIM DYNAMIC LCOUNT
#DIM DYNAMIC 対象

SIF !CFLAG:対象:血縁コード
	RETURNF -1

IF NOF(対象) > 10000
	RETURNF CFLAG:対象:血縁コード%100000
ELSE
	SIF CFLAG:対象:続柄 >= 1000
		RETURNF -1
	FOR LCOUNT, 1, 10000
		IF EXISTCSV(LCOUNT) && CSVCFLAG(LCOUNT, GETNUM(CFLAG, "血縁コード")) == CFLAG:対象:血縁コード
			SIF LCOUNT != NOF(対象) && CSVCFLAG(LCOUNT, GETNUM(CFLAG, "続柄")) == 1001
				RETURNF LCOUNT
		ENDIF
	NEXT
ENDIF

RETURNF -1
