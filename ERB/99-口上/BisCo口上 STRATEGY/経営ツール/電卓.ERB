@CALCULATOR

;表示している値のための変数
#DIM DYNAMIC DISPLAY
;格納している値のための変数
#DIM DYNAMIC MEMORY
;演算子を管理する変数 1:＋ 2:－ 3:× 4:÷ 5:＾
#DIM DYNAMIC OPERATOR
#DIM DYNAMIC 表示桁数
#DIM DYNAMIC 入力桁数

DO
	PRINTL
	IF OPERATOR == 1
		PRINTFORML  {MEMORY}＋
	ELSEIF OPERATOR == 2
		PRINTFORML  {MEMORY}－
	ELSEIF OPERATOR == 3
		PRINTFORML  {MEMORY}×
	ELSEIF OPERATOR == 4
		PRINTFORML  {MEMORY}÷
	ELSEIF OPERATOR == 5
		PRINTFORML  {MEMORY}＾
	ELSE
		PRINTL
	ENDIF
	PRINTFORML 【{DISPLAY}】
	PRINTBUTTON "[   AC   ]", "AC"
	PRINTBUTTON "[ C ]", "C"
	PRINTBUTTON "[ ^ ]", "^"
	PRINTL 　◆キーボードでの入力方法◆
	PRINT [ 7 ][ 8 ][ 9 ]
	PRINTBUTTON "[ / ]", "/"
	PRINTL 　数字は一度に入力することができますが、
	PRINT [ 4 ][ 5 ][ 6 ]
	PRINTBUTTON "[ * ]", "*"
	PRINTL 　数字と記号はEnterキーで分けて入力してください。
	PRINT [ 1 ][ 2 ][ 3 ]
	PRINTBUTTON "[ - ]", "-"
	PRINTL 　また、"Quit"などの命令は全て大文字か全て小文字
	PRINT [ 0 ]
	PRINTBUTTON "[   ＝   ]", "="
	PRINTBUTTON "[ + ]", "+"
	PRINTL 　もしくは頭文字のみでも入力できます。
	PRINTBUTTON "[       Quit       ]", "Quit"
	PRINTL
	INPUTS
	IF RESULTS == "0" || TOINT(RESULTS) != 0
		RESULT = TOINT(RESULTS)
		;マイナスの値の入力は表示が0のときのみ有効
		IF DISPLAY == 0
			DISPLAY = RESULT
		ELSEIF RESULT >= 0
			;表示している桁数の計算
			表示桁数 = 1 + LOG10(ABS(DISPLAY))
			;入力された桁数の計算
			IF RESULT == 0
				入力桁数 = 1
			ELSE
				入力桁数 = 1 + LOG10(RESULT)
			ENDIF
			;値が100京以上になるなら入力しなおし
			SIF 表示桁数 + 入力桁数 < 19
				DISPLAY = DISPLAY * POWER(10,入力桁数) + SIGN(DISPLAY)*RESULT
		ENDIF
	ELSEIF RESULTS == "" || RESULTS == "=" || RESULTS == "+" || RESULTS == "-" || RESULTS == "*" || RESULTS == "/" || RESULTS == "^"
		IF OPERATOR == 0
			MEMORY = DISPLAY
		ELSEIF OPERATOR == 1
			MEMORY += DISPLAY
		ELSEIF OPERATOR == 2
			MEMORY -= DISPLAY
		ELSEIF OPERATOR == 3
			;値を100京未満に抑える
			SIF DISPLAY == 0 || MEMORY == 0 || (LOG10(ABS(DISPLAY))) + (LOG10(ABS(MEMORY))) < 17
				MEMORY *= DISPLAY
		ELSEIF OPERATOR == 4
			SIF DISPLAY != 0
				MEMORY /= DISPLAY
		ELSEIF OPERATOR == 5
			;値を100京未満に抑える
			SIF MEMORY == 0 ||  DISPLAY*(1+LOG10(ABS(MEMORY))) < 18
				MEMORY = POWER(MEMORY,DISPLAY)
		ENDIF
		IF RESULTS != "="
			DISPLAY = 0
		ELSE
			DISPLAY = MEMORY
			MEMORY = 0
		ENDIF
		IF RESULTS == "+"
			OPERATOR = 1
		ELSEIF RESULTS == "-"
			OPERATOR = 2
		ELSEIF RESULTS == "*"
			OPERATOR = 3
		ELSEIF RESULTS == "/"
			OPERATOR = 4
		ELSEIF RESULTS == "^"
			OPERATOR = 5
		ELSE
			OPERATOR = 0
		ENDIF
	ELSEIF RESULTS == "C" || RESULTS == "c"
		DISPLAY = 0
	ELSEIF RESULTS == "AC" || RESULTS == "Ac" || RESULTS == "ac" || RESULTS == "A" || RESULTS == "a"
		DISPLAY = 0
		MEMORY = 0
		OPERATOR = 0
	ELSEIF RESULTS == "QUIT" || RESULTS == "Quit" || RESULTS == "quit" || RESULTS == "Q" || RESULTS == "q"
		RETURN DISPLAY
	ENDIF
LOOP 1


@D_CALCULATOR
;126bitの足し算引き算掛け算ができる
;表示している値のための変数
#DIM DYNAMIC DISPLAY, 2
#DIMS DYNAMIC DISPLAYS
;格納している値のための変数
#DIM DYNAMIC MEMORY, 2
;演算子を管理する変数 1:＋ 2:－ 3:×
#DIM DYNAMIC OPERATOR
;指数表記の指数部分の桁数
#DIM DYNAMIC EXPO = 3
#DIM DYNAMIC 入力値

DO
	PRINTL
	;#;PRINTFORML DISPLAY:0...{DISPLAY:0}
	;#;PRINTFORML DISPLAY:1...{DISPLAY:1}
	;#;PRINTFORML MEMORY:0....{MEMORY:0}
	;#;PRINTFORML MEMORY:1....{MEMORY:1}
	IF OPERATOR
		PRINT  
		CALL PRTD(MEMORY, MEMORY:1)
		SELECTCASE OPERATOR
			CASE 1
				PRINTL ＋
			CASE 2
				PRINTL －
			CASE 3
				PRINTL ×
		ENDSELECT
	ENDIF
	CALL D2DEC(DISPLAY, DISPLAY:1)
	DISPLAYS = 
	SIF RESULT < 0
		DISPLAYS = -
	DISPLAYS += D2STR(RESULT:1, RESULT:2, RESULT:3, RESULT:4)
	PRINTFORML 【%DISPLAYS%】
	PRINT   └→
	SIF RESULT < 0
		PRINT -
	PRINTFORML %D2EN(RESULT:1, RESULT:2, RESULT:3, RESULT:4, EXPO, 0)%
	PRINTBUTTON "[   AC   ]", "AC"
	PRINTBUTTON "[ C ]", "C"
	PRINTBUTTON "[ UP]", "UP"
	PRINTL 　◆キーボードでの入力方法◆
	PRINT [ 7 ][ 8 ][ 9 ]
	PRINTBUTTON "[ DN]", "DN"
	PRINTL 　数字は一度に入力することができますが、
	PRINT [ 4 ][ 5 ][ 6 ]
	PRINTBUTTON "[ * ]", "*"
	PRINTL 　数字と記号はEnterキーで分けて入力してください。
	PRINT [ 1 ][ 2 ][ 3 ]
	PRINTBUTTON "[ - ]", "-"
	PRINTL 　また、"Quit"などの命令は全て大文字か全て小文字
	PRINT [ 0 ]
	PRINTBUTTON "[   ＝   ]", "="
	PRINTBUTTON "[ + ]", "+"
	PRINTL 　もしくは頭文字のみでも入力できます。
	PRINTBUTTON "[       Quit       ]", "Quit"
	PRINTL
	INPUTS
	SELECTCASE TOUPPER(RESULTS)
		CASE "", "=", "+", "-", "*"
			SELECTCASE OPERATOR
				CASE 0
					MEMORY:0 = DISPLAY:0
					MEMORY:1 = DISPLAY:1
				CASE 1
					CALL D_PLUS(MEMORY:0, MEMORY:1, DISPLAY:0, DISPLAY:1)
					MEMORY:0 = RESULT:0
					MEMORY:1 = RESULT:1
				CASE 2
					CALL D_PLUS(MEMORY:0, MEMORY:1, -DISPLAY:0, -DISPLAY:1)
					MEMORY:0 = RESULT:0
					MEMORY:1 = RESULT:1
				CASE 3
					IF !(MEMORY*DISPLAY)
						IF MEMORY
							CALL D_MULTI(DISPLAY:1, MEMORY, MEMORY:1)
						ELSE
							CALL D_MULTI(MEMORY:1, DISPLAY, DISPLAY:1)
						ENDIF
						MEMORY:0 = RESULT:0
						MEMORY:1 = RESULT:1
					ENDIF
			ENDSELECT
			IF RESULTS != "="
				VARSET DISPLAY
			ELSE
				DISPLAY:0 = MEMORY:0
				DISPLAY:1 = MEMORY:1
				VARSET MEMORY
			ENDIF
			SELECTCASE RESULTS
				CASE "+"
					OPERATOR = 1
				CASE "-"
					OPERATOR = 2
				CASE "*"
					OPERATOR = 3
				CASEELSE
					OPERATOR = 0
			ENDSELECT
		CASE "UP", "U"
			EXPO++
		CASE "DOWN", "DN", "D"
			SIF EXPO > 0
				EXPO--
		CASE "C"
			VARSET DISPLAY
		CASE "AC", "A"
			VARSET DISPLAY
			VARSET MEMORY
			OPERATOR = 0
		CASE "QUIT", "Q"
			RETURN 0
		CASEELSE
			IF ISNUMERIC(RESULTS)
				入力値 = TOINT(RESULTS)
				;マイナスの値の入力は表示が0のときのみ有効
				IF DISPLAY == 0 && DISPLAY:1 == 0
					CALL DEC2D(RESULTS)
					DISPLAY:0 = RESULT:0
					DISPLAY:1 = RESULT:1
				ELSEIF 入力値 >= 0
					DISPLAYS += RESULTS
					CALL DEC2D(DISPLAYS)
					DISPLAY:0 = RESULT:0
					DISPLAY:1 = RESULT:1
				ENDIF
			ENDIF
	ENDSELECT
LOOP 1

@CHKOVF(ARGUMENT, ARGUMENT:1)
;|ARGUMENT+ARGUMENT:1|>=2^63かどうかをチェックする
;2^63以上なら1、-2^63以下なら-1、それ以外なら0を返す
#FUNCTION
#DIM DYNAMIC N62A
#DIM DYNAMIC N62B
#DIM DYNAMIC ARGUMENT, 2

SELECTCASE SIGN(ARGUMENT)*SIGN(ARGUMENT:1)
	CASE 1
		SELECTCASE GETBIT(ABS(ARGUMENT),62)+GETBIT(ABS(ARGUMENT:1),62)
			CASE 2
				RETURNF SIGN(ARGUMENT)
			CASE 1
				N62A = ABS(ARGUMENT) - GETBIT(ABS(ARGUMENT),62)*POWER(2,62)
				N62B = ABS(ARGUMENT:1) - GETBIT(ABS(ARGUMENT:1),62)*POWER(2,62)
				IF N62A+N62B >= POWER(2,62)
					RETURNF SIGN(ARGUMENT)
				ELSE
					RETURNF 0
				ENDIF
			CASE 0
				RETURNF 0
		ENDSELECT
	CASEELSE
		RETURNF 0
ENDSELECT

@D_PLUS(ARGUMENT=0, ARGUMENT:1=0, ARGUMENT:2=0, ARGUMENT:3=0)
;{ARGUMENT*2^63+ARGUMENT:1}+{ARGUMENT:2*2^63+ARGUMENT:3}を計算する
;答えは[ANS63]*2^63+[ANS0]となる
;返り値の3つ目で絶対値が2^126を超えたかどうかを示す
;1で2^126以上、-1で-2^126以下、0でそれ以外
;2^62 = 4611686018427387904
;2^63 = 9223372036854775808
#DIM DYNAMIC ANS0
#DIM DYNAMIC ANS63
#DIM DYNAMIC INTO63
#DIM DYNAMIC XARGUMENT
#DIM CONST LIM = 9223372036854775807
#DIM DYNAMIC ARGUMENT, 4

SELECTCASE CHKOVF(ARGUMENT:1, ARGUMENT:3)
	CASE 1
		INTO63 = 1
		ANS0 = ARGUMENT:1
		ANS0 -= 1p62
		ANS0 += ARGUMENT:3
		ANS0 -= 1p62
	CASE -1
		INTO63 = -1
		ANS0 = ARGUMENT:1
		ANS0 += 1p62
		ANS0 += ARGUMENT:3
		ANS0 += 1p62
	CASE 0
		ANS0 = ARGUMENT:1 + ARGUMENT:3
ENDSELECT

;オーバーフローをしていない繰り上がり繰り下がりの処理
;値を破壊しないようにARGUMENTをXARGUMENTに入れておく
XARGUMENT = ARGUMENT
;ANS0がマイナスなのに、ANS63がプラスになるのなら繰り下がりを行う
IF ANS0 < 0
	SELECTCASE SIGN(ARGUMENT)*SIGN(ARGUMENT:2)
		CASE 1
			;同符号
			IF ARGUMENT > 0
				XARGUMENT -= 1
				ANS0 += 1p62
				ANS0 += 1p62
			ENDIF
		CASEELSE
			;異符号もしくは少なくとも1つが0
			IF ARGUMENT+ARGUMENT:2 > 1
				XARGUMENT -= 1
				ANS0 += 1p62
				ANS0 += 1p62
			ELSEIF ARGUMENT+ARGUMENT:2 == 1 && INTO63 == 0
				XARGUMENT -= 1
				ANS0 += 1p62
				ANS0 += 1p62
			ENDIF
	ENDSELECT
;ANS0がプラスなのに、ANS63がマイナスになるのなら繰り上がりを行う
ELSEIF ANS0 > 0
	SELECTCASE SIGN(ARGUMENT)*SIGN(ARGUMENT:2)
		CASE 1
			;同符号
			IF ARGUMENT < 0
				XARGUMENT += 1
				ANS0 -= 1p62
				ANS0 -= 1p62
			ENDIF
		CASEELSE
			;異符号もしくは少なくとも1つが0
			IF ARGUMENT+ARGUMENT:2 < -1
				XARGUMENT += 1
				ANS0 -= 1p62
				ANS0 -= 1p62
			ELSEIF ARGUMENT+ARGUMENT:2 == -1 && INTO63 == 0
				XARGUMENT += 1
				ANS0 -= 1p62
				ANS0 -= 1p62
			ENDIF
	ENDSELECT
ENDIF

SELECTCASE CHKOVF(XARGUMENT, ARGUMENT:2)
	CASE 1
		RETURN LIM, LIM, 1
	CASE -1
		RETURN -LIM, -LIM, -1
	CASE 0
		IF XARGUMENT+ARGUMENT:2 == LIM && INTO63 == 1
			RETURN LIM, LIM, 1
		ELSEIF XARGUMENT+ARGUMENT:2 == -LIM && INTO63 == -1
			RETURN -LIM, -LIM, -1
		ELSE
			ANS63 = XARGUMENT + ARGUMENT:2 + INTO63
			RETURN ANS63, ANS0, 0
		ENDIF
ENDSELECT

@D_NORM(ARGUMENT, ARGUMENT:1)
#DIM ANS, 2
#DIM DYNAMIC ARGUMENT, 2
;ARGUMENT*2^63+ARGUMENT:1を想定したとき、ARGUMENTとARGUMENT:1が異符号であるものを同符号に直す
;それをここでは便宜上「正規化」と呼ぶことにする
IF SIGN(ARGUMENT)*SIGN(ARGUMENT:1) == -1
	IF ARGUMENT > 0
		ANS = ARGUMENT - 1
		ANS:1 = ARGUMENT:1 - 1p62
		ANS:1 -= 1p62
	ELSE
		ANS = ARGUMENT + 1
		ANS:1 = ARGUMENT:1 + 1p62
		ANS:1 += 1p62
	ENDIF
ELSE
	ANS = ARGUMENT
	ANS:1 = ARGUMENT:1
ENDIF
RETURN ANS, ANS:1

@D_MULTI(ARGUMENT=0, ARGUMENT:1=0, ARGUMENT:2=0)
;{ARGUMENT}*{ARGUMENT:1*2^63+ARGUMENT:2}を計算する
;答えは[ANS63]*2^63+[ANS0]となる
;返り値の3つ目で絶対値が2^126を超えたかどうかを示す
;1で2^126以上、-1で-2^126以下、0でそれ以外
;二進数での掛け算(63桁×126桁)の筆算をイメージ
#DIM DYNAMIC ANS0
#DIM DYNAMIC ANS63
#DIM DYNAMIC XARGUMENT, 3
#DIM DYNAMIC ANSIGN
#DIM DYNAMIC LCL, 126
#DIM DYNAMIC SUBT, 127
#DIM DYNAMIC LCOUNT, 2
#DIM DYNAMIC CARRY
#DIM CONST LIM = 9223372036854775807
#DIM DYNAMIC ARGUMENT, 3

CALL D_NORM(ARGUMENT:1, ARGUMENT:2)
ANSIGN = SIGN(SIGN(RESULT)+SIGN(RESULT:1))*SIGN(ARGUMENT)
XARGUMENT = ABS(ARGUMENT)
XARGUMENT:1 = ABS(RESULT)
XARGUMENT:2 = ABS(RESULT:1)

FOR LCOUNT, 0, 63
	SIF GETBIT(XARGUMENT:2,LCOUNT)
		LCL:LCOUNT = XARGUMENT
NEXT
FOR LCOUNT, 0, 63
	SIF GETBIT(XARGUMENT:1,LCOUNT)
		LCL:(63+LCOUNT) = XARGUMENT
NEXT

FOR LCOUNT, 0, 63
	FOR LCOUNT:1, 0, LCOUNT+1
		SUBT:LCOUNT += GETBIT(LCL:(LCOUNT:1), LCOUNT-LCOUNT:1)
	NEXT
NEXT
FOR LCOUNT, 0, 63
	FOR LCOUNT:1, 0, 63
		SUBT:(63+LCOUNT) += GETBIT(LCL:(1+LCOUNT+LCOUNT:1), 62-LCOUNT:1)
	NEXT
NEXT

FOR LCOUNT, 0, 62
	SUBT:126 += GETBIT(LCL:(64+LCOUNT), 62-LCOUNT)
NEXT

FOR LCOUNT, 0, 63
	SUBT:LCOUNT += CARRY
	SIF SUBT:LCOUNT%2
		SETBIT ANS0, LCOUNT
	CARRY = SUBT:LCOUNT/2
NEXT
FOR LCOUNT, 0, 63
	SUBT:(63+LCOUNT) += CARRY
	SIF SUBT:(63+LCOUNT)%2
		SETBIT ANS63, LCOUNT
	CARRY = SUBT:(63+LCOUNT)/2
NEXT
SUBT:126 += CARRY

IF SUBT:126 > 0
	RETURN ANSIGN*LIM, ANSIGN*LIM, ANSIGN
ELSE
	RETURN ANSIGN*ANS63, ANSIGN*ANS0, 0
ENDIF

@DEC2D(ARGUMENTS)
;文字列として入力された十進数の"数値"を「[ANS63]*2^63+[ANS0]」に直す
#DIM DYNAMIC OVF
#DIM DYNAMIC E0
#DIM DYNAMIC E15
#DIM DYNAMIC E30
#DIM DYNAMIC ANS0
#DIM DYNAMIC ANS63
#DIM DYNAMIC ANSIGN
#DIM DYNAMIC DIGIT
#DIM DYNAMIC LCL, 2
#DIM CONST E30TOB, 2 = 108420217248, 5076944270305263616
#DIM CONST LIM = 9223372036854775807
#DIMS DYNAMIC LSTR
#DIMS DYNAMIC ARGUMENTS

IF CHARATU(ARGUMENTS, 0) == "-"
	ANSIGN = -1
	LSTR = %SUBSTRING(ARGUMENTS, 1)%
ELSE
	ANSIGN = 1
	LSTR = %ARGUMENTS%
ENDIF

DIGIT = STRLENS(LSTR)
IF DIGIT > 30
	E30 = TOINT(SUBSTRING(LSTR, 0, DIGIT-30))
	E15 = TOINT(SUBSTRING(LSTR, DIGIT-30, 15))
	 E0 = TOINT(SUBSTRING(LSTR, DIGIT-15, 15))
ELSEIF DIGIT > 15
	E15 = TOINT(SUBSTRING(LSTR, 0, DIGIT-15))
	 E0 = TOINT(SUBSTRING(LSTR, DIGIT-15, 15))
ELSE
	 E0 = TOINT(LSTR)
ENDIF
ANS0 = E0

IF E15
	CALL D_MULTI, 1e15, 0, E15
	LCL:0 = RESULT
	LCL:1 = RESULT:1
	CALL D_PLUS, 0, ANS0, LCL:0, LCL:1
	ANS63 = RESULT
	ANS0 = RESULT:1
ENDIF

IF E30
	CALL D_MULTI, E30, E30TOB:0, E30TOB:1
	LCL:0 = RESULT
	LCL:1 = RESULT:1
	OVF = RESULT:2
	SIF OVF
		RETURN OVF*LIM, OVF*LIM, OVF
	CALL D_PLUS, ANS63, ANS0, LCL:0, LCL:1
	ANS63 = RESULT
	ANS0 = RESULT:1
	OVF = RESULT:2
	SIF OVF
		RETURN OVF*LIM, OVF*LIM, OVF
ENDIF

RETURN ANSIGN*ANS63, ANSIGN*ANS0, 0

@D2DEC(ARGUMENT, ARGUMENT:1)
;「ARGUMENT*2^63+ARGUMENT:1」を「[ANS36]*10^36+[ANS24]*10^24+[ANS12]*10^12+[ANS0]」に直す
;10^12ごとに区切ったのは、10^4ごとに区切る漢字文化圏の命数法と10^3ごとに区切る西洋の命数法の両方で使いやすくするためである
;10^12……1兆, 1 trillion, 1T(テラ)
;10^24……1𥝱, 1 septillion, 1Y(ヨタ)
;10^36……1澗, 1 undecillion, 1U(ウダ ※Jim Blowersによる私案)
#DIM ANS36, 126
#DIM ANS24, 126
#DIM ANS12, 126
#DIM ANS0, 126
#DIM MAKE2P
#DIM DYNAMIC ANS36T
#DIM DYNAMIC ANS24T
#DIM DYNAMIC ANS12T
#DIM DYNAMIC ANS0T
#DIM DYNAMIC XARGUMENT, 2
#DIM DYNAMIC LBIT
#DIM DYNAMIC ANSIGN
#DIM DYNAMIC ARGUMENT, 2

CALL D_NORM(ARGUMENT, ARGUMENT:1)
ANSIGN = SIGN(SIGN(RESULT)+SIGN(RESULT:1))
XARGUMENT = ABS(RESULT)
XARGUMENT:1 = ABS(RESULT:1)

IF !MAKE2P
	ANS0:0 = 1
	ANS12:0 = 0
	ANS24:0 = 0
	ANS36:0 = 0
	FOR LBIT, 1, 126
		ANS0:LBIT = 2*ANS0:(LBIT-1)
		ANS12:LBIT = 2*ANS12:(LBIT-1)
		ANS24:LBIT = 2*ANS24:(LBIT-1)
		ANS36:LBIT = 2*ANS36:(LBIT-1)
		IF ANS0:LBIT >= 1e12
			ANS12:LBIT++
			ANS0:LBIT -= 1e12
		ENDIF
		IF ANS12:LBIT >= 1e12
			ANS24:LBIT++
			ANS12:LBIT -= 1e12
		ENDIF
		IF ANS24:LBIT >= 1e12
			ANS36:LBIT++
			ANS24:LBIT -= 1e12
		ENDIF
	NEXT
	MAKE2P = 1
ENDIF

FOR LBIT, 0, 63
	IF GETBIT(XARGUMENT:1, LBIT)
		ANS0T += ANS0:LBIT
		ANS12T += ANS12:LBIT
		ANS24T += ANS24:LBIT
		ANS36T += ANS36:LBIT
	ENDIF
NEXT
FOR LBIT, 63, 126
	IF GETBIT(XARGUMENT, LBIT-63)
		ANS0T += ANS0:LBIT
		ANS12T += ANS12:LBIT
		ANS24T += ANS24:LBIT
		ANS36T += ANS36:LBIT
	ENDIF
NEXT

ANS12T += ANS0T/1e12
ANS0T %= 1e12
ANS24T += ANS12T/1e12
ANS12T %= 1e12
ANS36T += ANS24T/1e12
ANS24T %= 1e12

RETURN ANSIGN, ANS36T, ANS24T, ANS12T, ANS0T

;以下の関数は上記で作った12桁ごとに区切られた数を表すための関数
@DLOG10(ARGUMENT, ARGUMENT:1, ARGUMENT:2, ARGUMENT:3)
;要するに十進数での桁数-1
;桁数を数える用途なのでDLOG10(0)にも0を返す
;なお2^126-1は38桁、ここでは37を返す
#FUNCTION
#DIM DYNAMIC NONZERO
#DIM DYNAMIC LCL
#DIM DYNAMIC ARGUMENT, 4

IF ARGUMENT > 0
	NONZERO = 0
ELSEIF ARGUMENT:1 > 0
	NONZERO = 1
ELSEIF ARGUMENT:2 > 0
	NONZERO = 2
ELSE
	NONZERO = 3
ENDIF

IF ARGUMENT:(NONZERO) <= 0
	LCL = 0
ELSE
	LCL = LOG10(ARGUMENT:(NONZERO))
ENDIF

LCL += 12*(3-NONZERO)

RETURNF LCL

@D2STR(ARGUMENT, ARGUMENT:1, ARGUMENT:2, ARGUMENT:3)
;1本の文字列にする関数
#FUNCTIONS
#DIM DYNAMIC LCOUNT
#DIM DYNAMIC DIGIT
#DIMS DYNAMIC LSTR
#DIM DYNAMIC ARGUMENT, 4

DIGIT = 1+DLOG10(ARGUMENT, ARGUMENT:1, ARGUMENT:2, ARGUMENT:3)
IF DIGIT > 36
	LSTR += TOSTR(ARGUMENT)
	FOR LCOUNT, 0, 12-STRLENS(TOSTR(ARGUMENT:1))
		LSTR += "0"
	NEXT
ENDIF
IF DIGIT > 24
	LSTR += TOSTR(ARGUMENT:1)
	FOR LCOUNT, 0, 12-STRLENS(TOSTR(ARGUMENT:2))
		LSTR += "0"
	NEXT
ENDIF
IF DIGIT > 12
	LSTR += TOSTR(ARGUMENT:2)
	FOR LCOUNT, 0, 12-STRLENS(TOSTR(ARGUMENT:3))
		LSTR += "0"
	NEXT
ENDIF
LSTR += TOSTR(ARGUMENT:3)

RETURNF LSTR


@PRTD(ARGUMENT, ARGUMENT:1)
#DIMS DYNAMIC 返り値
#DIM DYNAMIC ARGUMENT, 2

CALL D2DEC(ARGUMENT, ARGUMENT:1)
返り値 = 
SIF RESULT < 0
	返り値 = -
返り値 += D2STR(RESULT:1, RESULT:2, RESULT:3, RESULT:4)
PRINTFORM %返り値%

@D2EN(ARGUMENT, ARGUMENT:1, ARGUMENT:2, ARGUMENT:3, MDIGIT, TYPE=-1, ZERO=0)
;指数表記(exponential notation) A*10^N (0<A<10, Nは整数) で表す関数
;MDIGITで仮数部(mantissa)Aの小数点以下の桁数を指定する
;TYPEは表示できる仮数部の一番下の位をどう扱うか
;	-1……切り捨て, 0……四捨五入, 1……切り上げ
;ZEROは指数部分が1桁のときに"0"で埋めるか
;0以外を入力していると埋める (例:1.7e04)
#FUNCTIONS
#DIM DYNAMIC MDIGIT
#DIM DYNAMIC TYPE
#DIM DYNAMIC ZERO
#DIM DYNAMIC LCOUNT
#DIM DYNAMIC LCL
#DIMS DYNAMIC LSTR
#DIMS DYNAMIC MSTR
#DIM DYNAMIC ARGUMENT, 4

LSTR = %D2STR(ARGUMENT, ARGUMENT:1, ARGUMENT:2, ARGUMENT:3)%

IF TYPE == 0
	SIF TOINT(CHARATU(LSTR, 1+MDIGIT)) >= 5
		GOTO ROUNDUP
ELSEIF TYPE > 0
	IF TOINT(SUBSTRING(LSTR, 1+MDIGIT))
		$ROUNDUP
		FOR LCOUNT, MDIGIT, -1, -1
			LCL = TOINT(CHARATU(LSTR, LCOUNT))
			IF LCL == 9
				LSTR = %SUBSTRING(LSTR, 0, LCOUNT)%0%SUBSTRING(LSTR, LCOUNT+1)%
				SIF LCOUNT == 0
					LSTR = 1%LSTR%
			ELSE
				LSTR = %SUBSTRING(LSTR, 0, LCOUNT)%%TOSTR(LCL+1)%%SUBSTRING(LSTR, LCOUNT+1)%
				BREAK
			ENDIF
		NEXT
	ENDIF
ENDIF

MSTR += CHARATU(LSTR, 0)
IF MDIGIT > 0
	MSTR += "."
	MSTR += SUBSTRING(LSTR, 1, MDIGIT)
	IF STRLENS(LSTR)-1 < MDIGIT
		FOR LCOUNT, 0, 1+MDIGIT-STRLENS(LSTR)
			MSTR += "0"
		NEXT
	ENDIF
ENDIF

MSTR += "e"
SIF STRLENS(LSTR)-1 <= 9 && ZERO
	MSTR += "0"

MSTR += TOSTR(STRLENS(LSTR)-1)

RETURNF MSTR
