@LOOPRES(ARG:0 = -1, ARG:1 = -1, ARG:2 = -1, ARG:3 = -1, ARG:4 = -1, ARG:5 = -1, ARG:6 = -1, ARG:7 = -1, ARG:8 = -1, ARG:9 = -1)
#FUNCTION
;式中関数「LOOPRES(LOOP RESULT)」
;DO～LOOP構文の記述を簡略化するための関数
;引数で指定された数字とRESULTを参照し、一致していれば0を返す(つまりLOOPを抜ける)
;現在同時に指定できるのは10個まで
REPEAT 10
	SIF RESULT == ARG:COUNT
		RETURNF 0
REND

RETURNF 1

@SEX, ARG
#FUNCTION
;式中関数「SEX」
;性別を判別するための関数
;引数で指定された対象の性別が、男なら1、女なら2を返す
RETURNF TALENT:ARG:性別

@CHECK_CHILD_CARE, ARG
#FUNCTION
;式中関数「CHECK_CHILD_CARE」
;育児室に居るかどうか判別するための関数
;引数で指定されたキャラを対象に判別する
;オリコ「くノ一忍法帖」ならスルー
SIF 受験段位名 == "くノ一忍法帖"
	RETURNF 0
SIF (TALENT:ARG:妊娠 && PREG:ARG:10-5 <= DAY) || TALENT:ARG:育児中
	RETURNF 1

RETURNF 0

@PENIS, ARG
#FUNCTION
;式中関数「PENIS」
;対象にちんこ生えてるかどうか ぱんくしょんにもあったな
;ARGが-1だと0を返すので、対象や助手が居ないのに参照してエラーになることはない
SIF ARG == -1
	RETURNF 0
SIF SEX(ARG) == 1 || TALENT:ARG:ふたなり
	RETURNF 1

RETURNF 0

@VAGINA, ARG
#FUNCTION
;式中関数「VAGINA」
;対象にまんこあるかどうか ぱんくしょんにもあったかどうかは知らん
;ARGが-1だと0を返すので、対象や助手が居ないのに参照してエラーになることはない
SIF ARG == -1
	RETURNF 0
SIF SEX(ARG) == 2 || TALENT:ARG:ふたなり
	RETURNF 1

RETURNF 0

@OVER_GENITAL, ARG
#FUNCTIONS
;式中関数「OVER_GENITAL」
;対象の性器を覆い隠している服は何か 一番上の服が返される 下半身上着＝全身上着＞下半身下着
SIF TEQUIP:ARG:全身上着 && CFLAG:ARG:着衣併用 != 1
	RETURNF CSTR:ARG:全身上着

SIF TEQUIP:ARG:下半身上着
	RETURNF CSTR:ARG:下半身上着

SIF TEQUIP:ARG:下半身下着
	RETURNF CSTR:ARG:下半身下着

@OVER_BUST, ARG
#FUNCTIONS
;式中関数「OVER_BUST」
;対象の乳房を覆い隠している服は何か 一番上の服が返される 上半身上着＝全身上着＞上半身下着
SIF TEQUIP:ARG:全身上着 && CFLAG:ARG:着衣併用 != 1
	RETURNF CSTR:ARG:全身上着

SIF TEQUIP:ARG:上半身上着
	RETURNF CSTR:ARG:上半身上着

SIF TEQUIP:ARG:上半身下着
	RETURNF CSTR:ARG:上半身下着

@ズリ穴作り, ARG, ARG:1
#FUNCTION
;式中関数「ズリ穴作り」
;対象ARGの服が自主的に服に穴などを作ることによりパイズリできる状態かを判別する
;ARG:1 = 0 なら通常のパイズリ ARG:1 = 1 なら縦パイズリ
;できる場合、1を返す
IF TEQUIP:ARG:上半身上着 || (TEQUIP:ARG:全身上着 && CFLAG:ARG:着衣併用!=1)
	IF CFLAG:ARG:上着パイズリ == 5
		IF TEQUIP:ARG:上半身下着
			SELECTCASE CFLAG:ARG:下着パイズリ
				CASE 1
					SIF ARG:1 == 0
						RETURNF 1
				CASE 2
					SIF ARG:1 == 1
						RETURNF 1
				CASE 3
					RETURNF 1
			ENDSELECT
		ELSE
			RETURNF 1
		ENDIF
	ENDIF
ENDIF
RETURNF 0

@FALLTYPE, ARG
#FUNCTION
;式中関数「FALLTYPE」
;陥落素質のタイプ eraBEMANIでは恋慕系、淫乱系、服従系のどれか一つしか取得できないので、
;恋慕or親愛だと1 淫乱or娼婦だと2 服従or隷属だと3を返す 未陥落は0
IF TALENT:ARG:恋慕 || TALENT:ARG:親愛
	RETURNF 1
ELSEIF TALENT:ARG:淫乱 || TALENT:ARG:娼婦
	RETURNF 2
ELSEIF TALENT:ARG:服従 || TALENT:ARG:隷属
	RETURNF 3
ELSE
	RETURNF 0
ENDIF

@性器露出, ARG
#FUNCTION
;式中関数「性器露出」
;単に性器が露出している状態かどうかを判別 OVER_GENITALとは少し違う(スカート系が対象にならない)
SELECTCASE OVER_GENITAL(ARG)
	CASE ""
		RETURNF 1
	CASE CSTR:ARG:下半身上着, CSTR:ARG:全身上着
		IF TEQUIP:ARG:下半身下着
			RETURNF 0
		ELSEIF CFLAG:ARG:挿入可
			RETURNF 1
		ELSE
			RETURNF 0
		ENDIF
	CASE CSTR:ARG:下半身下着
		RETURNF 0
ENDSELECT

RETURNF 0

@生殖機能♂, ARG = -1
#FUNCTION
SIF ARG == -1
	ARG = TARGET

SIF TALENT:ARG:無機物
	RETURNF 0

SIF CSTR:ARG:種族 == "機械"
	RETURNF 0

SIF TALENT:ARG:ゾンビ
	RETURNF 0

SELECTCASE CFLAG:ARG:精管結紮
	CASE 1
		RETURNF 0
	CASE 2
		SIF CFLAG:ARG:不妊担当魔術師 == NO:MASTER || (ASSI >= 0 && CFLAG:ARG:不妊担当魔術師 == NO:ASSI)
			RETURNF 0
ENDSELECT

RETURNF 1

@生殖機能♀, ARG = -1
#FUNCTION
SIF ARG == -1
	ARG = TARGET

SIF !VAGINA(ARG)
	RETURNF 0

SIF TALENT:ARG:無機物
	RETURNF 0

SIF CSTR:ARG:種族 == "機械"
	RETURNF 0

SELECTCASE CFLAG:ARG:卵管結紮
	CASE 1
		RETURNF 0
	CASE 2
		SIF CFLAG:ARG:不妊担当魔術師 == NO:MASTER || (ASSI >= 0 && CFLAG:ARG:不妊担当魔術師 == NO:ASSI)
			RETURNF 0
ENDSELECT

RETURNF 1

;引数で指定した素質名の番号を返す式中関数
@TALENTF, ARGS
#FUNCTION
#DIM DYNAMIC LCOUNT

FOR LCOUNT, 0, VARSIZE("TALENT")
	SIF TALENTNAME:LCOUNT == ARGS
		RETURNF LCOUNT
NEXT

;引数のキャラのNAMEを返すが、NOの範囲が1～9999じゃないと返さない プレイヤーの名前入力による予期せぬ挙動を防ぐため
@CHARANAMEF, ARG
#FUNCTIONS

SIF ARG < 0 || ARG >= CHARANUM
	RETURNF 

SELECTCASE NO:ARG
	CASE 1 TO 9999
		RETURNF NAME:ARG
	CASEELSE
		RETURNF 
ENDSELECT

;
;引数のキャラ番号のNAMEを返す。CSVが無い子供の場合はあらかじめ記録しておいたCHILDNAMEを返す
@CSVNAMEF, ARG
#FUNCTIONS

SELECTCASE ARG
	CASE 0 TO 9999
		SIF EXISTCSV(ARG)
			RETURNF CSVNAME(ARG)
	CASEELSE
		RETURNF CHILDNAME:(ARG-10000)
ENDSELECT

;引数のキャラ番号のCALLNAMEを返す。CSVが無い子供の場合はあらかじめ記録しておいたCHILDNAMEを返す
@CSVCALLNAMEF, ARG
#FUNCTIONS

SELECTCASE ARG
	CASE 0 TO 9999
		SIF EXISTCSV(ARG)
			RETURNF CSVCALLNAME(ARG)
	CASEELSE
		RETURNF CHILDNAME:(ARG-10000)
ENDSELECT

;GETCHARAのNAME版 上記CHARANAMEFと同じでNOの範囲が1～9999じゃないと返さない プレイヤーの名前入力による予期せぬ挙動を防ぐため
@GETCHARANAME, ARGS
#FUNCTION

LOCAL = FINDCHARA(NAME, ARGS)

SIF LOCAL >= 0 && INRANGE(NO:LOCAL, 1, 9999)
	RETURNF LOCAL

RETURNF -1

;以下パセリロゴ表示のための関数 式中関数じゃないけどほとんど式中関数みたいな使い方なので
@PASELI, ARGS
;PRINT
#DIM DYNAMIC LCOUNT

VARSET LOCALS

SPLIT ARGS, "＄", LOCALS

FOR LCOUNT, 0, RESULT
	IF LCOUNT >= 1
		IF FLAG:パセリ表示
			PRINT_IMG "PASELI"
		ELSEIF 通貨単位 != ""
			PRINTFORM %通貨単位%
		ELSE
			PRINT $
		ENDIF
	ENDIF
	PRINTFORM %LOCALS:LCOUNT%
NEXT

@PASELIL, ARGS
;PRINTL
#DIM DYNAMIC LCOUNT

VARSET LOCALS

SPLIT ARGS, "＄", LOCALS

FOR LCOUNT, 0, RESULT
	IF LCOUNT >= 1
		IF FLAG:パセリ表示
			PRINT_IMG "PASELI"
		ELSEIF 通貨単位 != ""
			PRINTFORM %通貨単位%
		ELSE
			PRINT $
		ENDIF
	ENDIF
	PRINTFORM %LOCALS:LCOUNT%
NEXT

PRINTL 

@PASELIW, ARGS
;PRINTW
#DIM DYNAMIC LCOUNT

VARSET LOCALS

SPLIT ARGS, "＄", LOCALS

FOR LCOUNT, 0, RESULT
	IF LCOUNT >= 1
		IF FLAG:パセリ表示
			PRINT_IMG "PASELI"
		ELSEIF 通貨単位 != ""
			PRINTFORM %通貨単位%
		ELSE
			PRINT $
		ENDIF
	ENDIF
	PRINTFORM %LOCALS:LCOUNT%
NEXT

PRINTW 

@PASELIPLAIN, ARGS
;PRINTPLAIN
#DIM DYNAMIC LCOUNT

VARSET LOCALS

SPLIT ARGS, "＄", LOCALS

FOR LCOUNT, 0, RESULT
	IF LCOUNT >= 1
		IF FLAG:パセリ表示
			PRINT_IMG "PASELI"
		ELSEIF 通貨単位 != ""
			PRINTFORM %通貨単位%
		ELSE
			PRINT $
		ENDIF
	ENDIF
	PRINTPLAINFORM %LOCALS:LCOUNT%
NEXT


;2桁の数値を直接入力するための関数
;ARGは最大値
;ARGSは単位
;ARG:1は最低値
@TWO_DIGIT, 最大値, 単位, 最低値
#DIM 最大値
#DIMS 単位
#DIM 最低値
#DIM DYNAMIC LCOUNT

VARSET LOCAL, 0

PRINTL キーボードによる直接入力もできます

DO
	PRINTL
	IF LOCAL >= 10
		PRINTFORM 【 %TOFULL(TOSTR(LOCAL/10))%
	ELSE
		PRINT 【 　
	ENDIF
	PRINTFORML %TOFULL(TOSTR(LOCAL%10))% 】%単位%

	
	;一の位は100～109を入力されると決まる RESULT-100とかRESULT%100とか
	;十の位は200～290を入力されると決まる (RESULT-200)/10とか？
	FOR LCOUNT, 0, 10
		VARSET LOCALS, 
		IF 最大値 >= LCOUNT*10 && 最低値 <= LCOUNT*10
			LOCALS = <font color='#c0c0c0'><button value='{200+LCOUNT*10}'>[ {LCOUNT} ]</button></font>
		ELSE
			LOCALS = <font color='#c0c0c0'>     </font>
		ENDIF
		IF 最大値 >= LCOUNT
			LOCALS:1 = <font color='#c0c0c0'><button value='{100+LCOUNT}'>[ {LCOUNT} ]</button></font>
		ENDIF
		HTML_PRINT LOCALS+LOCALS:1
	NEXT
	PRINTBUTTON "[  決定  ]", 999
	PRINTBUTTON "[ 最大値 ]", 最大値
	PRINTBUTTON "[ 最低値 ]", 最低値
	PRINTL 
	INPUT
	
	;キーボード入力で最低値～最大値の範囲外ならそれを返す
	SIF INRANGE(RESULT, 最低値, 最大値)
		RETURN RESULT

	;決定が押されればLOCALの値を返す
	IF RESULT == 999
		CLEARLINE 1
		RETURN LOCAL
	ENDIF

	SELECTCASE RESULT
		;一の位の処理 一の位を0にしてから加算する
		CASE 100 TO 109
			LOCAL = (LOCAL/10)*10+(RESULT-100)
		;十の位の処理 十の位を0にしてから加算する
		CASE 200 TO 290
			;プレイヤーが変なの入力した時用に一の位を抹消する
			RESULT -= RESULT%10
			LOCAL = (LOCAL%10)+(RESULT-200)
	ENDSELECT
	;最低値～最大値を超えてたらそれぞれ最低値か最高値に置き換える
	SIF LOCAL > 最大値
	LOCAL = LIMIT(LOCAL, 最低値, 最大値)
	CLEARLINE 14
LOOP 1


;素数かどうかを判定する
;素数なら1,それ以外(合成数・1以下の整数)なら0
@ISPRIME(ARG)
#FUNCTION
SIF ARG < 2
	RETURNF 0
SIF ARG == 2
	RETURNF 1
SIF ARG % 2 == 0
	RETURNF 0
FOR ARG:1, 3, SQRT(ARG)+1, 2
	SIF ARG % ARG:1 == 0
		RETURNF 0
NEXT
RETURNF 1


;平方数(整数を2乗してできる数)なら1を返す式中関数
@ISSQUARE(ARG)
#FUNCTION
SIF ARG < 0
	RETURNF 0
IF ARG == SQRT(ARG)*SQRT(ARG)
	RETURNF 1
ELSE
	RETURNF 0
ENDIF


;約数関数
;ARGの正の約数全てをARG:1乗した総和を表す
;ARG:1が0で約数の個数、ARG:1が1で約数の総和を求める
;ARGが0のとき特例で0、ARGが負でABS(ARG)での値にマイナスをつける
@SIGMA(ARG, ARG:1=1)
#FUNCTION
#DIM DYNAMIC LCOUNT
#DIM DYNAMIC LSUM

SIF ARG == 0
	RETURNF 0

FOR LCOUNT, 1, ABS(ARG)+1
	SIF ABS(ARG)%LCOUNT == 0
		LSUM += POWER(LCOUNT, ARG:1)
NEXT
LSUM *= SIGN(ARG)

RETURNF LSUM


;整数ARGの4/3乗を返す関数
;負の数でもエラーは吐かないようになっている
;また、結果をARG:1倍にもできる(3乗根の中で計算するので誤差があまり大きくならない)
;係数による2^63エラーの対策はとっていないので注意
@POW4V3(ARG, ARG:1=1)
#FUNCTION
#DIM DYNAMIC LCL
IF ABS(ARG) < 9800
	LCL = CBRT( 1000 * POWER(ARG,4) * POWER(ABS(ARG:1),3) ) / 10
ELSE
	LCL = ABS(ARG) * CBRT( 1000 * ABS(ARG) * POWER(ABS(ARG:1),3) ) / 10
ENDIF
RETURNF LCL


;近親相姦の判定用関数
;1なら兄弟間、2なら親子間、それ以外なら0
@近親相姦, ARG, ARG:1
#FUNCTION

SIF ARG < 0 && ARG:1 < 0
	RETURNF 0

IF CFLAG:ARG:血縁コード >= 1 && CFLAG:ARG:血縁コード == CFLAG:(ARG:1):血縁コード
	IF CFLAG:ARG:続柄 >= 1000 || CFLAG:(ARG:1):続柄 >= 1000
		RETURNF 2
	ELSE
		RETURNF 1
	ENDIF
ELSE
	SIF NO:ARG >= 10000 && (CFLAG:ARG:血縁コード/100000 == NO:(ARG:1) || CFLAG:ARG:血縁コード%100000 == NO:(ARG:1))
		RETURNF 2
	SIF NO:(ARG:1) >= 10000 && (CFLAG:(ARG:1):血縁コード/100000 == NO:ARG || CFLAG:(ARG:1):血縁コード%100000 == NO:ARG)
		RETURNF 2
ENDIF

RETURNF 0

;膣に道具入ってるかどうかの式中関数
@Ｖ使用中, ARG = -1
#FUNCTION
SIF ARG == -1
	ARG = TARGET

SIF TEQUIP:ARG:バイブ
	RETURNF 1
SIF TEQUIP:ARG:Ｖ異物
	RETURNF 1
SIF TEQUIP:ARG:ペニスバンド
	RETURNF 1

RETURNF 0

;表記ゆれ（半角）にも対応
@V使用中, ARG = -1
#FUNCTION
RETURNF Ｖ使用中(ARG)

;アナルに道具入ってるかどうかの式中関数
@Ａ使用中, ARG = -1
#FUNCTION
SIF ARG == -1
	ARG = TARGET

SIF TEQUIP:ARG:アナルバイブ
	RETURNF 1
SIF TEQUIP:ARG:アナルビーズ
	RETURNF 1
SIF TEQUIP:ARG:浣腸器
	RETURNF 1
SIF TEQUIP:ARG:拡張バルーン
	RETURNF 1
SIF TEQUIP:ARG:アナル電極
	RETURNF 1
SIF TEQUIP:ARG:Ａ異物
	RETURNF 1
SIF TEQUIP:ARG:電動エネマグラ
	RETURNF 1

RETURNF 0

;表記ゆれ（半角）にも対応
@A使用中, ARG = -1
#FUNCTION
RETURNF Ａ使用中(ARG)

;胸で道具使ってるかどうかの式中関数
@Ｂ使用中, ARG = -1
#FUNCTION
SIF ARG == -1
	ARG = TARGET

SIF TEQUIP:ARG:ニプルキャップ
	RETURNF 1
SIF TEQUIP:ARG:搾乳器
	RETURNF 1
SIF TEQUIP:ARG:乳房電極
	RETURNF 1

RETURNF 0

;表記ゆれ（半角）にも対応
@B使用中, ARG = -1
#FUNCTION
RETURNF Ｂ使用中(ARG)

;GETNUM(PALAM, "STR")をさらに簡略化したもの。ABL上昇処理で頻繁に使用しているのでPALAM用に作った
;GETPALAMLVではない
@GETPALAM, ARGS
#FUNCTION
RETURNF GETNUM(PALAM, ARGS)

;GETNUM(EXP, "STR")をさらに簡略化したもの。ABL上昇処理で頻繁に使用しているのでEXP用に作った
;GETEXPLVではない
@GETEXP, ARGS
#FUNCTION
RETURNF GETNUM(EXP, ARGS)

;第一引数に第二引数のツールチップ付けたHTML_PRINT用の完成されたタグを返す式中関数
;"[]"で囲った部分があれば自動でボタン化する
;ボタン化フラグを0にすればボタン化しない
@SET_TOOLTIP, 本文, ツールチップ, ボタン化 = 1, 文字色
#FUNCTIONS
#DIMS DYNAMIC 本文
#DIMS DYNAMIC ツールチップ
#DIMS DYNAMIC タグ
;ボタンの数値が指定されたボタン番号と一致すると困るので、ボタン化されなさそうな数値に 元ネタ分かる人はすごい
#DIM DYNAMIC ボタン = -3189415
#DIMS DYNAMIC 文字列ボタン
#DIM DYNAMIC ボタン化
#DIMS DYNAMIC 文字色

VARSET LOCAL

;STRCOUNTの使い方がわからない
LOCAL = STRFINDU(本文, "[")
LOCAL:1 = STRFINDU(本文, "]")

IF LOCAL != -1 && LOCAL:1 != -1
	;STRFIND系使うと"[～]"の範囲を取得してるので"["と"]"を省くために+1と-1する
	文字列ボタン = %SUBSTRINGU(本文, LOCAL+1, LOCAL:1-LOCAL-1)%
	SIF ISNUMERIC(文字列ボタン)
		ボタン = TOINT(文字列ボタン)
ENDIF

;文字色指定してればその文字色で
IF 文字色 != ""
	タグ = <font color='%文字色%'>
ELSE
	タグ = <font color='#%CONVERT(GETCOLOR(), 16)%'>
ENDIF

SIF !ボタン化
	GOTO NONBUTTON

;紛らわしいけどtitleがツールチップなんだよなぁ
IF ボタン != -3189415
	IF ツールチップ非表示
		タグ += @"<button value ='{ボタン}'>%本文%</button></font>"
	ELSE
		タグ += @"<button value ='{ボタン}' title = '%ツールチップ%'>%本文%</button></font>"
	ENDIF
ELSEIF 文字列ボタン != ""
	IF ツールチップ非表示
		タグ += @"<button value ='%文字列ボタン%'>%本文%</button></font>"
	ELSE
		タグ += @"<button value ='%文字列ボタン%' title = '%ツールチップ%'>%本文%</button></font>"
	ENDIF
ELSE
	$NONBUTTON
	IF ツールチップ非表示
		タグ += @"<nonbutton>%本文%</nonbutton></font>"
	ELSE
		タグ += @"<nonbutton title = '%ツールチップ%'>%本文%</nonbutton></font>"
	ENDIF
ENDIF

;RESETCOLOR

RETURNF タグ

;PRINTBUTTONのツールチップ付与版
;PRINTBUTTONと同じ使い方に加え、第三引数のツールチップ付けたHTML_PRINT用の完成されたタグを返す式中関数
;ただしPRINTBUTTONとは違い、第二引数がINT型であってもダブルクォーテーションて括らなければならない
@SET_TOOLTIPBUTTON, 本文, 文字列ボタン, ツールチップ, 文字色
#FUNCTIONS
#DIMS DYNAMIC 本文
#DIMS DYNAMIC ツールチップ
#DIMS DYNAMIC タグ
;ボタンの数値が指定されたボタン番号と一致すると困るので、ボタン化されなさそうな数値に 元ネタ分かる人はすごい
#DIM DYNAMIC ボタン = -3189415
#DIMS DYNAMIC 文字列ボタン
#DIM DYNAMIC ボタン化
#DIMS DYNAMIC 文字色

VARSET LOCAL

SIF ISNUMERIC(文字列ボタン)
	ボタン = TOINT(文字列ボタン)

;文字色指定してればその文字色で
IF 文字色 != ""
	タグ = <font color='%文字色%'>
ELSE
	タグ = <font color='#%CONVERT(GETCOLOR(), 16)%'>
ENDIF

;紛らわしいけどtitleがツールチップなんだよなぁ
IF ボタン != -3189415
	IF ツールチップ非表示
		タグ += @"<button value ='{ボタン}'>%本文%</button></font>"
	ELSE
		タグ += @"<button value ='{ボタン}' title = '%ツールチップ%'>%本文%</button></font>"
	ENDIF
ELSEIF 文字列ボタン != ""
	IF ツールチップ非表示
		タグ += @"<button value ='%文字列ボタン%'>%本文%</button></font>"
	ELSE
		タグ += @"<button value ='%文字列ボタン%' title = '%ツールチップ%'>%本文%</button></font>"
	ENDIF
ENDIF

;RESETCOLOR

RETURNF タグ

;引数の条件に一致するキャラをページ形式で表示する
;詳しくは資料フォルダの雑記.txtを参照
@PAGING, 表示, 追加情報, ページ名, 終了表記, 使用不可も表示
#DIM ページ数
#DIM 表示数
#DIM 飛ばした人数
#DIM 未表示キャラ
#DIM 表示行数
#DIM 選択可能, 10000
#DIM 初期化フラグ
#DIM DYNAMIC LCOUNT
#DIM DYNAMIC 表示
#DIM DYNAMIC 使用不可も表示
#DIM DYNAMIC クジャクアイ
#DIMS DYNAMIC 追加情報
#DIMS DYNAMIC ページ名
#DIMS DYNAMIC 終了表記

LCOUNT = PAGING

IF 初期化フラグ == 0
	VARSET 選択可能
	飛ばした人数 = 0
	表示数 = 0
	未表示キャラ = 0
	表示行数 = LINECOUNT
	初期化フラグ = 1
ENDIF

IF 表示 && (使用不可も表示 || !CFLAG:PAGING:使用不可)
	;2ページ目以降はページ数×10まで表示を飛ばす
	IF 飛ばした人数 < ページ数*10
		飛ばした人数++
		RETURN 0
	ENDIF

	表示数++
	;10人表示したら未表示キャラが居るフラグ立ててページ終わり
	IF 表示数 > 10
		未表示キャラ = 1
	ELSE
		;健康診断は色変えしたいので特別な処理
		IF 追加情報 == "健康診断用"
			PRINTFORM 　[{LCOUNT, 2, RIGHT}] - %NAME:LCOUNT, 26, LEFT% \@ SEX(LCOUNT) == 1 ? ♂ # ♀ \@ 体力%BARBASE("体力", PAGING, 10), 23, LEFT% 気力%BARBASE("気力", PAGING, 10), 23, LEFT% ストレス値:
			;孔雀の瞳を持ってるキャラが主人・助手・担当医に居るかを見る
			SIF TALENT:MASTER:孔雀の瞳
				クジャクアイ = 1
			SIF ASSI > 0 && TALENT:ASSI:孔雀の瞳
				クジャクアイ = 1
			FOR LCOUNT, 0, CHARANUM
				SIF CSTR:LCOUNT:配属 == "医務室" && TALENT:LCOUNT:孔雀の瞳
					クジャクアイ = 1
			NEXT
			LCOUNT = PAGING
			IF クジャクアイ
				SELECTCASE CFLAG:LCOUNT:ストレス値
					CASE 1 TO 99
						SETCOLORBYNAME lime
					CASE 100 TO 299
						SETCOLORBYNAME yellow
					CASE 300 TO 499
						SETCOLORBYNAME red
					CASE IS >= 500
						SETCOLORBYNAME darkred
				ENDSELECT
				PRINTFORML {CFLAG:LCOUNT:ストレス値}/999
			ELSE
				SELECTCASE CFLAG:LCOUNT:ストレス値
					CASE 0
						PRINTL 無
					CASE 1 TO 99
						SETCOLORBYNAME lime
						PRINTL 低
					CASE 100 TO 299
						SETCOLORBYNAME yellow
						PRINTL 中
					CASE 300 TO 499
						SETCOLORBYNAME red
						PRINTL 高
					CASE IS >= 500
						SETCOLORBYNAME darkred
						PRINTL 過多
				ENDSELECT
				RESETCOLOR
			ENDIF
			選択可能:LCOUNT = 1
		ELSE
			PRINTFORML 　[{LCOUNT, 2, RIGHT}] - %NAME:LCOUNT, 26, LEFT% \@ SEX(LCOUNT) == 1 ? ♂ # ♀ \@ %追加情報%
			選択可能:LCOUNT = 1
		ENDIF
	ENDIF
ENDIF

;表示数が10人になるか全キャラ表示したら入力受け付け
IF 表示数 > 10 || LCOUNT == CHARANUM-1
	;表示できるキャラが居ない場合
	IF 表示数 == 0
		DRAWLINE
		PRINTL 　表示できるキャラが居ません
	ENDIF
	DRAWLINE
	初期化フラグ = 0
	IF ページ名 == ""
		PRINTPLAINFORM 　PAGE.{ページ数+1}　
	ELSE
		PRINTPLAINFORM 　%ページ名%　
	ENDIF
	IF ページ数 > 0
		PRINTLC [999]前ページ
	ELSE
		PRINTLC  
	ENDIF
	IF 終了表記 == ""
		PRINTLC [1000] 戻る　
	ELSE
		PRINTFORMLC [1000] %終了表記%　
	ENDIF
	;表示できるキャラがまだ居れば次ページ
	SIF 未表示キャラ
		PRINTLC [1001]次ページ
	PRINTL 
	DO
		INPUT
		SELECTCASE RESULT
			CASE 999
				SIF ページ数 > 0
					ページ数--
				PAGING = -1
				CLEARLINE LINECOUNT-表示行数
				RETURN 0
			CASE 1000
				PAGING = CHARANUM
				ページ数 = 0
				RETURN -1
			CASE 1001
				;表示できるキャラがまだ居れば次ページ
				SIF 未表示キャラ
					ページ数++
				PAGING = -1
				CLEARLINE LINECOUNT-表示行数
				RETURN 0
			CASEELSE
				SIF !選択可能:RESULT
					CONTINUE
				PAGING = CHARANUM
				ページ数 = 0
				RETURN RESULT
		ENDSELECT
	LOOP 1
ENDIF

;第一引数(比較元)と第二引数(比較先)を比較して、条件で指定した動作を行う
;条件=UPの場合 - 比較先が比較元より大きい数だった場合は比較元を同じ値にする
;条件=DOWNの場合 - 比較先が比較元より小さい数だった場合は比較元を同じ値にする
;条件を指定しない場合はUPの動作 参照型変数なので比較元はこの関数内で変更される
@REF_DIFF, 比較元, 比較先, 条件 = "UP"
#DIM DYNAMIC REF 比較元
#DIM DYNAMIC 比較先
#DIMS DYNAMIC 条件

SELECTCASE 条件
	CASE "UP"
		SIF 比較元 < 比較先
			比較元 = 比較先
	CASE "DOWN"
		SIF 比較元 > 比較先
			比較元 = 比較先
ENDSELECT

;上記REF_DIFFの改良版 第一引数が第二引数より大きい場合は第二引数の値に合わせる
@SETMIN, 比較元, 比較先
#DIM DYNAMIC REF 比較元
#DIM DYNAMIC 比較先

SIF 比較元 > 比較先
	比較元 = 比較先

;上記SETMINのMAX版
@SETMAX, 比較元, 比較先
#DIM DYNAMIC REF 比較元
#DIM DYNAMIC 比較先

SIF 比較元 < 比較先
	比較元 = 比較先

;BASEのBARを表示する汎用関数
;指定が無ければ32分
@BARBASE, ARGS, ARG = -1, ARG:1 = 32
#FUNCTIONS
SIF ARG == -1
	ARG = TARGET
SIF ARG == -1
	RETURNF 

RETURNF @"%BARSTR(BASE:ARG:ARGS, MAXBASE:ARG:ARGS, ARG:1)%({BASE:ARG:ARGS}/{MAXBASE:ARG:ARGS})"

;対象のBASEがMAXBASEより高かったり0より低かったりしたら合わせる関数
;体力気力魔力のみ
@SETBASE, ARG
BASE:ARG:体力 = LIMIT(BASE:ARG:体力, 0, MAXBASE:ARG:体力)
BASE:ARG:気力 = LIMIT(BASE:ARG:気力, 0, MAXBASE:ARG:気力)
BASE:ARG:魔力 = LIMIT(BASE:ARG:魔力, 0, MAXBASE:ARG:魔力)

;改行しないウェイトする関数 大犬口上から本体に移動
@SLINEWAIT, ARGS
#DIM DYNAMIC LCOUNT, 2

VARSET LOCALS, 

SPLIT ARGS, "Ｗ", LOCALS

LOCALS = %HTML_POPPRINTINGSTR()%%LOCALS%

FOR LCOUNT, 0, RESULT
	IF LCOUNT >= 1
		WAIT
		CLEARLINE 1
	ENDIF
	FOR LCOUNT:1, 0, LCOUNT+1
		PRINTFORM %LOCALS:(LCOUNT:1)%
	NEXT
NEXT
PRINTW 

;CHECKDRAWLINE 現在表示してる最後の行がDRAWLINE行かどうかをチェックし、そうでなければDRAWLINEを引く関数
@CHECKDRAWLINE
SIF HTML_TOPLAINTEXT(HTML_GETPRINTEDSTR(0)) != DRAWLINESTR
	DRAWLINE

;CHECKDRAWLINEのWAIT付き版
@CHECKDRAWLINEW
IF HTML_TOPLAINTEXT(HTML_GETPRINTEDSTR(0)) != DRAWLINESTR
	WAIT
	DRAWLINE
ENDIF

;GETNO 引数のNAMEのキャラのNOを返す 子供にも対応しているが、同姓同名のキャラが入れば番号が若い方が優先される
@GETNO, 名前
#FUNCTION
#DIMS DYNAMIC 名前
#DIMS 名前保存用, 20000
#DIM DYNAMIC LCOUNT

IF 名前保存用 == ""
	FOR LCOUNT, 0, 20000
		SELECTCASE LCOUNT
			CASE 0 TO 9999
				SIF EXISTCSV(LCOUNT)
					名前保存用:LCOUNT = %CSVNAME(LCOUNT)%
			CASE IS > 10000
				SIF CHILDNAME:(LCOUNT-10000) == ""
					BREAK
				名前保存用:LCOUNT = %CHILDNAME:(LCOUNT-10000)%
		ENDSELECT
	NEXT
ENDIF

;#;SIF FINDELEMENT(名前保存用, 名前, 0, VARSIZE("名前保存用"), 1) == -1
;#;	THROW 「%名前%」というキャラは存在しないか、表記揺れです

RETURNF FINDELEMENT(名前保存用, 名前, 0, VARSIZE("名前保存用"), 1)

