@素数ダイス

#DIM DYNAMIC LCOUNT
#DIM DYNAMIC LCOUNT2


LOCAL:13 = 5;初期の持ち点
LOCAL:14 = LOCAL:13;自分の残り持ち点
LOCAL:15 = LOCAL:13;相手の残り持ち点
LOCAL:21 = 3;難易度
LOCAL:23 = 6;使用するダイスの数字
PD_RULE = 7;計算のルールを全て認めるなら7/結合を認めないなら6/結合・累乗を認めないなら5

$PRIME_DICE_RULE
PRINTL
PRINTL ◆素数ダイスのルール◆
PRINTFORML 4つのダイスをふって出た1～{LOCAL:23}の数字を使って
PRINTL 素数を作り出すゲームです。　例…6×6×3＋5＝113
PRINTFORML ＋－×÷と括弧\@ PD_RULE >= 6 ? と累乗 # \@が使えます。
SIF PD_RULE == 7
	PRINTL また、数字を結合させることも認められます。　例…121＋6＝127,(3×4＋1)＆1＝131
PRINTFORML 2人が同額のチップを{LOCAL:13}枚ずつ持ってゲームをします。
PRINTL 30秒以内に「前回より大きい素数」を1つ答えてください。回答は早押しです。
PRINTL 正解するたびに相手のチップを1枚奪うことができます。(その後のゲームには使えません)
PRINTL ただし、誤答をすると相手にチップを2枚渡さなくてはなりません。
PRINTL また、両者30秒間無回答だとお互いチップを1枚失います。
PRINTL どちらかのチップがなくなるとゲーム終了です。
PRINTL なお、最初の素数の大きさは対戦相手によります。
PRINTL
PRINTL ルールの変更をしますか？
PRINTL [0]しない [1]する
INPUT
IF RESULT != 0 && RESULT != 1
	GOTO PRIME_DICE_RULE
ELSEIF RESULT == 1
	$PRIME_DICE_OPTION
	PRINTL
	PRINTL 変更する項目を選択してください。
	PRINTFORML ■使用するダイスの種類 (現在のルール:1～{LOCAL:23})
	PRINT   
	PRINTBUTTON "[0]1～6", 0
	PRINTL  [1]1～8 [2]1～9 [3]1～12 [4]1～20
	PRINT ■累乗・結合の使用 (現在のルール:
	IF PD_RULE == 5
		PRINTL どちらも使用できない)
	ELSEIF PD_RULE == 6
		PRINTL 累乗のみ使用できる)
	ELSE
		PRINTL どちらも使用できる)
	ENDIF
	PRINT   
	PRINTBUTTON "[5]どちらも使用できない", 5
	PRINTL  [6]累乗のみ使用できる [7]どちらも使用できる
	PRINTL [8]設定を終えてルールを確認する
	PRINTL [9]設定を終えてゲームを開始する
	INPUT
	IF RESULT == 0
		LOCAL:23 = 6
	ELSEIF RESULT == 1
		LOCAL:23 = 8
	ELSEIF RESULT == 2
		LOCAL:23 = 9
	ELSEIF RESULT == 3
		LOCAL:23 = 12
	ELSEIF RESULT == 4
		LOCAL:23 = 20
	ELSEIF 5 <= RESULT && RESULT <= 7
		PD_RULE = RESULT
	ELSEIF RESULT == 8
		GOTO PRIME_DICE_RULE
	ELSEIF RESULT == 9
		GOTO PRIME_DICE_RULE_END
	ENDIF
	GOTO PRIME_DICE_OPTION
ENDIF
$PRIME_DICE_RULE_END

PRINTL
PRINTL 対戦相手の強さを選択してください
PRINTFORML 所持金:${MONEY}
PRINTFORML [0]弱い(賭け金:{LOCAL:13}×$100 最初の素数:1以上)
PRINTFORML [1]普通(賭け金:{LOCAL:13}×$500 最初の素数:10以上)
PRINTFORML [2]強い(賭け金:{LOCAL:13}×$1000 最初の素数:50以上)
PRINTFORML [3]最強(賭け金:{LOCAL:13}×$5000 最初の素数:100以上)
INPUT
IF RESULT < 0 || 3 < RESULT
	GOTO PRIME_DICE_RULE_END
ELSEIF RESULT == 0
	LOCAL:17 = 1;これより大きい素数を見つけなくてはならない
	LOCAL:21 = 0;難易度
	LOCAL:24 = 100;チップ1枚の価値
ELSEIF RESULT == 1
	LOCAL:17 = 10
	LOCAL:21 = 1
	LOCAL:24 = 500
ELSEIF RESULT == 2
	LOCAL:17 = 50
	LOCAL:21 = 2
	LOCAL:24 = 1000
ELSEIF RESULT == 3
	LOCAL:17 = 100
	LOCAL:21 = 3
	LOCAL:24 = 5000
ENDIF

PRINTL
PRINTW ゲームを開始します。

$PRIME_DICE_START

LOCAL:1 = 1+RAND:(LOCAL:23)
LOCAL:2 = 1+RAND:(LOCAL:23)
LOCAL:3 = 1+RAND:(LOCAL:23)
LOCAL:4 = 1+RAND:(LOCAL:23)
LOCAL:16 = (LOG(LOCAL:17)*12000 + RAND:20000)/(LOCAL:21+1);相手が回答するまでの時間
;ただし、30秒を超えると30秒に直される
;難易度3(最強)でも求める素数が22027(>exp(10)>22026)以上になると確実に30秒になる
;ちなみに22027は素数
;exp(1)=2.7 exp(2)=7.4 exp(3)=20.1 exp(4)=54.6 exp(5)=148.4
;exp(6)=403.4 exp(7)=1096.6 exp(8)=2980.96 exp(9)=8103.1 exp(10)=22026.5
SIF LOCAL:16 > 30000
	LOCAL:16 = 30000
PRINTL
DRAWLINE
LOCAL:5 = 0;経過時間の記録
LOCAL:18 = 0;相手が答えるかどうか
GETMILLISECOND
LOCAL:6 = RESULT;スタート時刻の取得
PRINTFORML チップ1枚:${LOCAL:24}
PRINTFORML %CALLNAME:MASTER%:{LOCAL:14}枚 相手プレイヤー:{LOCAL:15}枚
PRINTFORML ({LOCAL:1},{LOCAL:2},{LOCAL:3},{LOCAL:4})を全て使った{LOCAL:17}より大きい素数は？
PRINTL [0]画面上の10キーで入力 [-1]答えない
$PRIME_DICE_INPUT
TINPUT (LOCAL:16-LOCAL:5), -1, 0
IF RESULT < -1
	GETMILLISECOND
	LOCAL:5 += RESULT-LOCAL:6
	GOTO PRIME_DICE_INPUT
ELSEIF RESULT == -1
	;答えない場合、相手のターンへ
	LOCAL:18 = 1
ELSEIF RESULT == 0
	LOCAL:8 = 0;表示されている値
	LOCAL:11 = 0;格納している値
	LOCAL:12 = 0;格納している算術記号
	$PRIME_DICE_10KEY
	GETMILLISECOND
	LOCAL:5 = RESULT-LOCAL:6
	PRINTL
	PRINTFORML %CALLNAME:MASTER%:{LOCAL:14}枚 相手プレイヤー:{LOCAL:15}枚
	PRINTFORML ({LOCAL:1},{LOCAL:2},{LOCAL:3},{LOCAL:4})を全て使った{LOCAL:17}より大きい素数は？
	IF LOCAL:12 == 1
		PRINTFORML  {LOCAL:11}＋
	ELSEIF LOCAL:12 == 2
		PRINTFORML  {LOCAL:11}－
	ELSEIF LOCAL:12 == 3
		PRINTFORML  {LOCAL:11}×
	ELSEIF LOCAL:12 == 4
		PRINTFORML  {LOCAL:11}÷
	ELSEIF LOCAL:12 == 5
		PRINTFORML  {LOCAL:11}＾
	ELSE
		PRINTL
	ENDIF
	PRINTFORML 【{LOCAL:8}】
	PRINTBUTTON "[ AC ]", "AC"
	PRINTBUTTON "[C]", "C"
	PRINTBUTTON "[^]", "^"
	PRINTL 　◆キーボードでの入力方法◆
	PRINT [7][8][9]
	PRINTBUTTON "[/]", "/"
	PRINTL 　数字は一度に入力することができますが、
	PRINT [4][5][6]
	PRINTBUTTON "[*]", "*"
	PRINTL 　数字と記号はEnterキーで分けて入力してください。
	PRINT [1][2][3]
	PRINTBUTTON "[-]", "-"
	PRINTL 　また、"Submit"などの命令は全て大文字か全て小文字もしくは頭文字のみでも入力できます。
	PRINT [0]
	PRINTBUTTON "[ ＝ ]", "="
	PRINTBUTTON "[+]", "+"
	PRINT 　さらに、"Pass"を入力すると
	PRINTBUTTON "「答えない」", "Pass"
	PRINTL という選択ができます。
	PRINTBUTTON "[  Submit  ]", "Submit"
	PRINTL
	TINPUTS (LOCAL:16-LOCAL:5), "Pass", 0
	IF RESULTS == "0" || TOINT(RESULTS) != 0
		RESULT = TOINT(RESULTS)
		IF LOCAL:8 == 0
			LOCAL:8 = RESULT
		ELSEIF RESULT >= 0
			;表示している桁数の計算
			LOCAL:9 = 1 + LOG10(ABS(LOCAL:8))
			;入力された桁数の計算
			IF RESULT == 0
				LOCAL:10 = 1
			ELSE
				LOCAL:10 = 1 + LOG10(RESULT)
			ENDIF
			SIF LOCAL:8 != 0 && LOCAL:9 + LOCAL:10 < 17;答えが1京を超えるようなら入力しなおし
				LOCAL:8 = LOCAL:8 * POWER(10,LOCAL:10) + SIGN(LOCAL:8)*RESULT
			SIF LOCAL:8 == 0 && LOCAL:9 < 17
				LOCAL:8 = RESULT
		ENDIF
		GOTO PRIME_DICE_10KEY
	ELSEIF RESULTS == "=" || RESULTS == "+" || RESULTS == "-" || RESULTS == "*" || RESULTS == "/" || RESULTS == "^"
		IF LOCAL:12 == 0
			LOCAL:11 = LOCAL:8
		ELSEIF LOCAL:12 == 1
			LOCAL:11 += LOCAL:8
		ELSEIF LOCAL:12 == 2
			LOCAL:11 -= LOCAL:8
		ELSEIF LOCAL:12 == 3
			SIF LOCAL:8 == 0 || LOCAL:11 == 0 || (1+LOG10(ABS(LOCAL:8))) + (1+LOG10(ABS(LOCAL:11))) < 17
				LOCAL:11 *= LOCAL:8
		ELSEIF LOCAL:12 == 4
			SIF LOCAL:8 != 0
				LOCAL:11 /= LOCAL:8
		ELSEIF LOCAL:12 == 5
			SIF LOCAL:11 == 0 ||  LOCAL:8*(1+LOG10(ABS(LOCAL:11))) < 17
				LOCAL:11 = POWER(LOCAL:11,LOCAL:8)
		ENDIF
		IF RESULTS != "="
			LOCAL:8 = 0
		ELSE
			LOCAL:8 = LOCAL:11
			LOCAL:11 = 0
		ENDIF
		IF RESULTS == "+"
			LOCAL:12 = 1
		ELSEIF RESULTS == "-"
			LOCAL:12 = 2
		ELSEIF RESULTS == "*"
			LOCAL:12 = 3
		ELSEIF RESULTS == "/"
			LOCAL:12 = 4
		ELSEIF RESULTS == "^"
			LOCAL:12 = 5
		ELSE
			LOCAL:12 = 0
		ENDIF
		GOTO PRIME_DICE_10KEY
	ELSEIF RESULTS == "C" || RESULTS == "c"
		LOCAL:8 = 0
		GOTO PRIME_DICE_10KEY
	ELSEIF RESULTS == "AC" || RESULTS == "Ac" || RESULTS == "ac" || RESULTS == "A" || RESULTS == "a"
		LOCAL:8 = 0
		LOCAL:11 = 0
		LOCAL:12 = 0
		GOTO PRIME_DICE_10KEY
	ELSEIF RESULTS == "SUBMIT" || RESULTS == "Submit" || RESULTS == "submit" || RESULTS == "S" || RESULTS == "s"
		RESULT = LOCAL:8
		GOTO PRIME_DICE_JUDGE
	ELSEIF RESULTS == "PASS" || RESULTS == "Pass" || RESULTS == "pass" || RESULTS == "P" || RESULTS == "p"
		;答えない場合、相手のターンへ
		LOCAL:18 = 1
	ELSE
		PRINTL TEST
		GOTO PRIME_DICE_10KEY
	ENDIF
ELSE
	$PRIME_DICE_JUDGE
	PRINTL
	LOCAL = RESULT
	CALL ISCALC24, LOCAL, LOCAL:1, LOCAL:2, LOCAL:3, LOCAL:4
	IF RESULT
		CALL PRTFOMULA, CALC_PT, CALC_VAL:0, CALC_VAL:1, CALC_VAL:2, CALC_VAL:3
		PRINTFORM ＝{LOCAL}
		IF LOCAL > LOCAL:17
			PRINTFORML  ＞ {LOCAL:17}
			IF ISPRIME(LOCAL)
				PRINTFORML {LOCAL}は素数です。
				LOCAL:15 -= 1
				LOCAL:17 = LOCAL
			ELSE
				PRINTFORML {LOCAL}は素数ではありません。
				LOCAL:14 -= 2
			ENDIF
		ELSE
			PRINTFORML  ≦ {LOCAL:17}
			PRINTFORML 答えは{LOCAL:17}より大きくなければいけません。
			LOCAL:14 -= 2
		ENDIF
	ELSE
		PRINTFORML 答えが{LOCAL}になるような計算式は見つかりませんでした。
		LOCAL:14 -= 2
	ENDIF
ENDIF
IF LOCAL:18
	PRINTL
	LOCAL:20 = LOCAL:17
	IF LOCAL:21 == 1
		LOCAL:22 = SQRT(LOCAL:20)
	ELSEIF LOCAL:21 == 2
		LOCAL:22 = CBRT(LOCAL:20)
	ELSEIF LOCAL:21 == 3
		LOCAL:22 = SQRT(SQRT(LOCAL:20))
	ENDIF
	IF RAND:(1 + (LOCAL:22/(1+LOCAL:21))) == 0
		;求める素数が10万未満なら、確実に求めることができる
		FOR LCOUNT2, (LOCAL:17+3)/10+RAND:(1+LOCAL:21), (LOCAL:17+3)/10+10
			FOR LCOUNT, 0, 3
				LOCAL:19 = LCOUNT2*10 + 7 + LCOUNT*2
				IF ISPRIME(LOCAL:19)
					CALL ISCALC24, LOCAL:19, LOCAL:1, LOCAL:2, LOCAL:3, LOCAL:4
					IF RESULT
						PRINTL 相手プレイヤーが回答します。
						CALL PRTFOMULA, CALC_PT, CALC_VAL:0, CALC_VAL:1, CALC_VAL:2, CALC_VAL:3
						PRINTFORM ＝{LOCAL:19}
						PRINTFORML  ＞ {LOCAL:17}
						PRINTFORML {LOCAL:19}は素数です。
						LOCAL:17 = LOCAL:19
						LOCAL:14 -= 1
						GOTO PRIME_DICE_TURN_END
					ENDIF
				ENDIF
			NEXT
		NEXT
		PRINTL 30秒経ちましたが、
		PRINTL 相手プレイヤーも回答しませんでした。
		LOCAL:14 -= 1
		LOCAL:15 -= 1
	ELSEIF RAND:(1+ LOCAL:22/(CBRT(LOCAL:20))) == 0 && LOCAL:16 == 30000
		PRINTL 30秒経ちましたが、
		PRINTL 相手プレイヤーも回答しませんでした。
		LOCAL:14 -= 1
		LOCAL:15 -= 1
	ELSE
		;当てずっぽうで答える
		PRINTL 相手プレイヤーが回答します。
		LOCAL = ((LOCAL:17+3)/10+RAND:(1+LOCAL:21))*10 + 7 + 2*RAND:4
		CALL ISCALC24, LOCAL, LOCAL:1, LOCAL:2, LOCAL:3, LOCAL:4
		IF RESULT
			CALL PRTFOMULA, CALC_PT, CALC_VAL:0, CALC_VAL:1, CALC_VAL:2, CALC_VAL:3
			PRINTFORM ＝{LOCAL}
			PRINTFORML  ＞ {LOCAL:17}
			IF ISPRIME(LOCAL)
				PRINTFORML {LOCAL}は素数です。
				LOCAL:14 -= 1
				LOCAL:17 = LOCAL
			ELSE
				PRINTFORML {LOCAL}は素数ではありません。
				LOCAL:15 -= 2
			ENDIF
		ELSE
			PRINTFORML 相手プレイヤーは{LOCAL}と答えましたが、
			PRINTFORML 答えが{LOCAL}になるような計算式は見つかりませんでした。
			LOCAL:15 -= 2
		ENDIF
	ENDIF
ENDIF
$PRIME_DICE_TURN_END

IF LOCAL:14 <= 0 || LOCAL:15 <= 0
	PRINTL
	PRINTW チップがなくなったプレイヤーがいるためゲーム終了です。
	PRINTL
	DRAWLINE
	PRINTFORML チップ開始時:{LOCAL:13}枚
	PRINTFORML 残ったチップ:{LOCAL:14}枚
	PRINTFORML 奪ったチップ:{LOCAL:13-LOCAL:15}枚
	PRINTFORML チップ総収支:\@ LOCAL:14-LOCAL:15 >0 ? + # \@{LOCAL:14-LOCAL:15}枚
	PRINTFORML チップ単価　:${LOCAL:24}
	LOCAL:25 = LOCAL:24*(LOCAL:14-LOCAL:15)
	IF LOCAL:25 > 0
		PRINTFORMW 総収支　　　:+${LOCAL:25}
	ELSEIF LOCAL:25 < 0
		PRINTFORMW 総収支　　　:-${ABS(LOCAL:25)}
	ELSE
		PRINTFORMW 総収支　　　:$0
	ENDIF
	MONEY += LOCAL:25
ELSE
	PRINTL
	PRINTW 次のゲームへ進みます。
	GOTO PRIME_DICE_START
ENDIF


;ISCALCで返ってきた値に対し式を出力する
@PRTFOMULA, ARG, ARG:1, ARG:2, ARG:3, ARG:4
;以下演算子(+,-,*,/,累乗,結合)を★、
;ARG:1-ARG:4をそれぞれA-Dとする
;※「最も内側の括弧」の記述の行に対しインデントをつけました
;(i):((A★B)★C)★D
IF INRANGE(ARG, 10000, 70000) && (ARG/100)%100 <= 6
	SETCOLOR 0x00FF00
	PRINT (
	SETCOLOR 0xFFFF00
		PRINT (
		RESETCOLOR
		PRINTFORM {ARG:1}
		SETCOLOR 0x00FFFF
		CALL PRTOPERATOR, ARG%100
		RESETCOLOR
		PRINTFORM {ARG:2}
		SETCOLOR 0xFFFF00
		PRINT )
	CALL PRTOPERATOR, ARG/100%100
	RESETCOLOR
	PRINTFORM {ARG:3}
	SETCOLOR 0x00FF00
	PRINT )
	CALL PRTOPERATOR, ARG/10000
	RESETCOLOR
	PRINTFORM {ARG:4}
ENDIF
;(ii):(A★(B★C))★D
IF INRANGE(ARG, 10000, 70000) && 7 <= (ARG/100)%100
	SETCOLOR 0x00FF00
	PRINT (
	RESETCOLOR
	PRINTFORM {ARG:1}
	SETCOLOR 0xFFFF00
	CALL PRTOPERATOR, ARG/100%100
		PRINT (
		RESETCOLOR
		PRINTFORM {ARG:2}
		SETCOLOR 0x00FFFF
		CALL PRTOPERATOR, ARG%100
		RESETCOLOR
		PRINTFORM {ARG:3}
		SETCOLOR 0xFFFF00
		PRINT )
	SETCOLOR 0x00FF00
	PRINT )
	CALL PRTOPERATOR, ARG/10000
	RESETCOLOR
	PRINTFORM {ARG:4}
ENDIF
;(iii):A★((B★C)★D)
IF INRANGE(ARG, 70000, 130000) && (ARG/100)%100 <= 6
	PRINTFORM {ARG:1}
	SETCOLOR 0x00FF00
	CALL PRTOPERATOR, ARG/10000
	PRINT (
	SETCOLOR 0xFFFF00
		PRINT (
		RESETCOLOR
		PRINTFORM {ARG:2}
		SETCOLOR 0x00FFFF
		CALL PRTOPERATOR, ARG%100
		RESETCOLOR
		PRINTFORM {ARG:3}
		SETCOLOR 0xFFFF00
		PRINT )
	CALL PRTOPERATOR, ARG/100%100
	RESETCOLOR
	PRINTFORM {ARG:4}
	SETCOLOR 0x00FF00
	PRINT )
	RESETCOLOR
ENDIF
;(iv):A★(B★(C★D))
IF INRANGE(ARG, 70000, 130000) && 7 <= (ARG/100)%100
	PRINTFORM {ARG:1}
	SETCOLOR 0x00FF00
	CALL PRTOPERATOR, ARG/10000
	PRINT (
	RESETCOLOR
	PRINTFORM {ARG:2}
	SETCOLOR 0xFFFF00
	CALL PRTOPERATOR, ARG/100%100
		PRINT (
		RESETCOLOR
		PRINTFORM {ARG:3}
		SETCOLOR 0x00FFFF
		CALL PRTOPERATOR, ARG%100
		RESETCOLOR
		PRINTFORM {ARG:4}
		SETCOLOR 0xFFFF00
		PRINT )
	SETCOLOR 0x00FF00
	PRINT )
	RESETCOLOR
ENDIF
;(v):(A★B)★(C★D)
IF INRANGE(ARG, 100, 700)
	SETCOLOR 0x00FF00
	PRINT (
	RESETCOLOR
	PRINTFORM {ARG:1}
	SETCOLOR 0xFFFF00
	CALL PRTOPERATOR, ARG/10%10
	RESETCOLOR
	PRINTFORM {ARG:2}
	SETCOLOR 0x00FF00
	PRINT )
	CALL PRTOPERATOR, ARG/100
	PRINT (
	RESETCOLOR
	PRINTFORM {ARG:3}
	SETCOLOR 0xFFFF00
	CALL PRTOPERATOR, ARG%10
	RESETCOLOR
	PRINTFORM {ARG:4}
	SETCOLOR 0x00FF00
	PRINT )
	RESETCOLOR
ENDIF

;演算子を出力する
;＆は単純な結合
@PRTOPERATOR, ARG
SELECTCASE ARG%6
	CASE 1
		PRINT ＋
	CASE 2
		PRINT ×
	CASE 3
		PRINT －
	CASE 4
		PRINT ÷
	CASE 5
		PRINT ＾
	CASEELSE
		PRINT ＆
ENDSELECT


;ARGがARG:1からARG:4で計算可能かどうかを判定する
;順番を入れ替えた24通り全てで判別し、
;計算可能な場合、計算パターンをCALC_PTに、その順列をCALC_VAL:0,CALC_VAL:1,CALC_VAL:2,CALC_VAL:3に出力し、1を返す
;計算不可能な場合、0を返す
@ISCALC24, ARG, ARG:1, ARG:2, ARG:3, ARG:4
CALC_PT = 0
CALC_VAL:0 = 0
CALC_VAL:1 = 0
CALC_VAL:2 = 0
CALC_VAL:3 = 0
IF ISCALC(ARG, ARG:1, ARG:2, ARG:3, ARG:4)
	CALC_PT = ISCALC(ARG, ARG:1, ARG:2, ARG:3, ARG:4)
	CALC_VAL:0 = ARG:1
	CALC_VAL:1 = ARG:2
	CALC_VAL:2 = ARG:3
	CALC_VAL:3 = ARG:4
	RETURN 1
ELSEIF ISCALC(ARG, ARG:1, ARG:2, ARG:4, ARG:3)
	CALC_PT = ISCALC(ARG, ARG:1, ARG:2, ARG:4, ARG:3)
	CALC_VAL:0 = ARG:1
	CALC_VAL:1 = ARG:2
	CALC_VAL:2 = ARG:4
	CALC_VAL:3 = ARG:3
	RETURN 1
ELSEIF ISCALC(ARG, ARG:1, ARG:3, ARG:2, ARG:4)
	CALC_PT = ISCALC(ARG, ARG:1, ARG:3, ARG:2, ARG:4)
	CALC_VAL:0 = ARG:1
	CALC_VAL:1 = ARG:3
	CALC_VAL:2 = ARG:2
	CALC_VAL:3 = ARG:4
	RETURN 1
ELSEIF ISCALC(ARG, ARG:1, ARG:3, ARG:4, ARG:2)
	CALC_PT = ISCALC(ARG, ARG:1, ARG:3, ARG:4, ARG:2)
	CALC_VAL:0 = ARG:1
	CALC_VAL:1 = ARG:3
	CALC_VAL:2 = ARG:4
	CALC_VAL:3 = ARG:2
	RETURN 1
ELSEIF ISCALC(ARG, ARG:1, ARG:4, ARG:2, ARG:3)
	CALC_PT = ISCALC(ARG, ARG:1, ARG:4, ARG:2, ARG:3)
	CALC_VAL:0 = ARG:1
	CALC_VAL:1 = ARG:4
	CALC_VAL:2 = ARG:2
	CALC_VAL:3 = ARG:3
	RETURN 1
ELSEIF ISCALC(ARG, ARG:1, ARG:4, ARG:3, ARG:2)
	CALC_PT = ISCALC(ARG, ARG:1, ARG:4, ARG:3, ARG:2)
	CALC_VAL:0 = ARG:1
	CALC_VAL:1 = ARG:4
	CALC_VAL:2 = ARG:3
	CALC_VAL:3 = ARG:2
	RETURN 1
ELSEIF ISCALC(ARG, ARG:2, ARG:1, ARG:3, ARG:4)
	CALC_PT = ISCALC(ARG, ARG:2, ARG:1, ARG:3, ARG:4)
	CALC_VAL:0 = ARG:2
	CALC_VAL:1 = ARG:1
	CALC_VAL:2 = ARG:3
	CALC_VAL:3 = ARG:4
	RETURN 1
ELSEIF ISCALC(ARG, ARG:2, ARG:1, ARG:4, ARG:3)
	CALC_PT = ISCALC(ARG, ARG:2, ARG:1, ARG:4, ARG:3)
	CALC_VAL:0 = ARG:2
	CALC_VAL:1 = ARG:1
	CALC_VAL:2 = ARG:4
	CALC_VAL:3 = ARG:3
	RETURN 1
ELSEIF ISCALC(ARG, ARG:2, ARG:3, ARG:1, ARG:4)
	CALC_PT = ISCALC(ARG, ARG:2, ARG:3, ARG:1, ARG:4)
	CALC_VAL:0 = ARG:2
	CALC_VAL:1 = ARG:3
	CALC_VAL:2 = ARG:1
	CALC_VAL:3 = ARG:4
	RETURN 1
ELSEIF ISCALC(ARG, ARG:2, ARG:3, ARG:4, ARG:1)
	CALC_PT = ISCALC(ARG, ARG:2, ARG:3, ARG:4, ARG:1)
	CALC_VAL:0 = ARG:2
	CALC_VAL:1 = ARG:3
	CALC_VAL:2 = ARG:4
	CALC_VAL:3 = ARG:1
	RETURN 1
ELSEIF ISCALC(ARG, ARG:2, ARG:4, ARG:1, ARG:3)
	CALC_PT = ISCALC(ARG, ARG:2, ARG:4, ARG:1, ARG:3)
	CALC_VAL:0 = ARG:2
	CALC_VAL:1 = ARG:4
	CALC_VAL:2 = ARG:1
	CALC_VAL:3 = ARG:3
	RETURN 1
ELSEIF ISCALC(ARG, ARG:2, ARG:4, ARG:3, ARG:1)
	CALC_PT = ISCALC(ARG, ARG:2, ARG:4, ARG:3, ARG:1)
	CALC_VAL:0 = ARG:2
	CALC_VAL:1 = ARG:4
	CALC_VAL:2 = ARG:3
	CALC_VAL:3 = ARG:1
	RETURN 1
ELSEIF ISCALC(ARG, ARG:3, ARG:1, ARG:2, ARG:4)
	CALC_PT = ISCALC(ARG, ARG:3, ARG:1, ARG:2, ARG:4)
	CALC_VAL:0 = ARG:3
	CALC_VAL:1 = ARG:1
	CALC_VAL:2 = ARG:2
	CALC_VAL:3 = ARG:4
	RETURN 1
ELSEIF ISCALC(ARG, ARG:3, ARG:1, ARG:4, ARG:2)
	CALC_PT = ISCALC(ARG, ARG:3, ARG:1, ARG:4, ARG:2)
	CALC_VAL:0 = ARG:3
	CALC_VAL:1 = ARG:1
	CALC_VAL:2 = ARG:4
	CALC_VAL:3 = ARG:2
	RETURN 1
ELSEIF ISCALC(ARG, ARG:3, ARG:2, ARG:1, ARG:4)
	CALC_PT = ISCALC(ARG, ARG:3, ARG:2, ARG:1, ARG:4)
	CALC_VAL:0 = ARG:3
	CALC_VAL:1 = ARG:2
	CALC_VAL:2 = ARG:1
	CALC_VAL:3 = ARG:4
	RETURN 1
ELSEIF ISCALC(ARG, ARG:3, ARG:2, ARG:4, ARG:1)
	CALC_PT = ISCALC(ARG, ARG:3, ARG:2, ARG:4, ARG:1)
	CALC_VAL:0 = ARG:3
	CALC_VAL:1 = ARG:2
	CALC_VAL:2 = ARG:4
	CALC_VAL:3 = ARG:1
	RETURN 1
ELSEIF ISCALC(ARG, ARG:3, ARG:4, ARG:1, ARG:2)
	CALC_PT = ISCALC(ARG, ARG:3, ARG:4, ARG:1, ARG:2)
	CALC_VAL:0 = ARG:3
	CALC_VAL:1 = ARG:4
	CALC_VAL:2 = ARG:1
	CALC_VAL:3 = ARG:2
	RETURN 1
ELSEIF ISCALC(ARG, ARG:3, ARG:4, ARG:2, ARG:1)
	CALC_PT = ISCALC(ARG, ARG:3, ARG:4, ARG:2, ARG:1)
	CALC_VAL:0 = ARG:3
	CALC_VAL:1 = ARG:4
	CALC_VAL:2 = ARG:2
	CALC_VAL:3 = ARG:1
	RETURN 1
ELSEIF ISCALC(ARG, ARG:4, ARG:1, ARG:2, ARG:3)
	CALC_PT = ISCALC(ARG, ARG:4, ARG:1, ARG:2, ARG:3)
	CALC_VAL:0 = ARG:4
	CALC_VAL:1 = ARG:1
	CALC_VAL:2 = ARG:2
	CALC_VAL:3 = ARG:3
	RETURN 1
ELSEIF ISCALC(ARG, ARG:4, ARG:1, ARG:3, ARG:2)
	CALC_PT = ISCALC(ARG, ARG:4, ARG:1, ARG:3, ARG:2)
	CALC_VAL:0 = ARG:4
	CALC_VAL:1 = ARG:1
	CALC_VAL:2 = ARG:3
	CALC_VAL:3 = ARG:2
	RETURN 1
ELSEIF ISCALC(ARG, ARG:4, ARG:2, ARG:1, ARG:3)
	CALC_PT = ISCALC(ARG, ARG:4, ARG:2, ARG:1, ARG:3)
	CALC_VAL:0 = ARG:4
	CALC_VAL:1 = ARG:2
	CALC_VAL:2 = ARG:1
	CALC_VAL:3 = ARG:3
	RETURN 1
ELSEIF ISCALC(ARG, ARG:4, ARG:2, ARG:3, ARG:1)
	CALC_PT = ISCALC(ARG, ARG:4, ARG:2, ARG:3, ARG:1)
	CALC_VAL:0 = ARG:4
	CALC_VAL:1 = ARG:2
	CALC_VAL:2 = ARG:3
	CALC_VAL:3 = ARG:1
	RETURN 1
ELSEIF ISCALC(ARG, ARG:4, ARG:3, ARG:1, ARG:2)
	CALC_PT = ISCALC(ARG, ARG:4, ARG:3, ARG:1, ARG:2)
	CALC_VAL:0 = ARG:4
	CALC_VAL:1 = ARG:3
	CALC_VAL:2 = ARG:1
	CALC_VAL:3 = ARG:2
	RETURN 1
ELSEIF ISCALC(ARG, ARG:4, ARG:3, ARG:2, ARG:1)
	CALC_PT = ISCALC(ARG, ARG:4, ARG:3, ARG:2, ARG:1)
	CALC_VAL:0 = ARG:4
	CALC_VAL:1 = ARG:3
	CALC_VAL:2 = ARG:2
	CALC_VAL:3 = ARG:1
	RETURN 1
ELSE
	RETURN 0
ENDIF


;自然数ARGがARG:1からARG:4を用いて計算可能かどうかを判定する
;ただし、順番は入れ替えられない
@ISCALC(ARG,ARG:1,ARG:2,ARG:3,ARG:4)
#FUNCTION
;以下演算子(+,-,*,/,累乗,結合)を★、
;ARG:1-ARG:4をそれぞれA-Dとする
;(i):((A★B)★C)★D...10101-60606
FOR ARG:5, 1, PD_RULE
	FOR ARG:6, 1, PD_RULE
		FOR ARG:7, 1, PD_RULE
			CALC_ERR = 0
			FRAC:0:0 = 0
			FRAC:0:1 = 0
			IF CALC(CALC(CALC(ARG:1,ARG:2,ARG:7),ARG:3,ARG:6),ARG:4,ARG:5) == ARG
				SIF CALC_ERR == 0 && FRAC:0:1 == 0
					RETURNF ARG:5*10000+ARG:6*100+ARG:7
			ENDIF
		NEXT
	NEXT
NEXT
;(ii):(A★(B★C))★D...10701-11206
FOR ARG:5, 1, PD_RULE
	FOR ARG:6, 3, PD_RULE
		FOR ARG:7, 1, PD_RULE
			CALC_ERR = 0
			FRAC:0:0 = 0
			FRAC:0:1 = 0
			IF CALC(CALC2(ARG:1,CALC(ARG:2,ARG:3,ARG:7),ARG:6),ARG:4,ARG:5) == ARG
				SIF CALC_ERR == 0 && FRAC:0:1 == 0
					RETURNF ARG:5*10000+(ARG:6+6)*100+ARG:7
			ENDIF
		NEXT
	NEXT
NEXT
;(iii):A★((B★C)★D)...70101-120101
FOR ARG:5, 3, PD_RULE
	FOR ARG:6, 1, PD_RULE
		FOR ARG:7, 1, PD_RULE
			CALC_ERR = 0
			FRAC:0:0 = 0
			FRAC:0:1 = 0
			IF CALC2(ARG:1,CALC(CALC(ARG:2,ARG:3,ARG:7),ARG:4,ARG:6),ARG:5) == ARG
				SIF CALC_ERR == 0 && FRAC:0:1 == 0
					RETURNF (ARG:5+6)*10000+ARG:6*100+ARG:7
			ENDIF
		NEXT
	NEXT
NEXT
;(iv):A★(B★(C★D))...70701-121206
FOR ARG:5, 3, PD_RULE
	FOR ARG:6, 3, PD_RULE
		FOR ARG:7, 1, PD_RULE
			CALC_ERR = 0
			FRAC:0:0 = 0
			FRAC:0:1 = 0
			IF CALC2(ARG:1,CALC2(ARG:2,CALC(ARG:3,ARG:4,ARG:7),ARG:6),ARG:5) == ARG
				SIF CALC_ERR == 0 && FRAC:0:1 == 0
					RETURNF (ARG:5+6)*10000+(ARG:6+6)*100+ARG:7
			ENDIF
		NEXT
	NEXT
NEXT
;(v):(A★B)★(C★D)...111-666
FOR ARG:5, 1, PD_RULE
	FOR ARG:6, 1, PD_RULE
		FOR ARG:7, 1, PD_RULE
			CALC_ERR = 0
			FRAC:0:0 = 0
			FRAC:0:1 = 0
			FRAC:1:0 = 0
			FRAC:1:1 = 0
			IF CALC3(CALC(ARG:1,ARG:2,ARG:6),CALC1(ARG:3,ARG:4,ARG:7),ARG:5) == ARG
				SIF CALC_ERR == 0
					RETURNF (ARG:5)*100+(ARG:6)*10+ARG:7
			ENDIF
		NEXT
	NEXT
NEXT
RETURNF 0

;以下演算(1:+ 2:- 3:* 4:/ 5:累乗 6:結合)の処理
;やっちゃ駄目な計算をするとCALC_ERRに1が代入される

;ARG:2には演算子(1:+ 2:- 3:* 4:/ 5:累乗 6:結合)が入っている
;CALCに対し帯分数がくるときは必ずARG:0
@CALC(ARG:0,ARG:1,ARG:2)
#FUNCTION
SIF FRAC:0:1 == 0
	FRAC:0:0 = 0
IF ARG:2 == 1
	RETURNF ARG:0 + ARG:1
ELSEIF ARG:2 == 2
	FRAC:0:0 *= ARG:1
	FRAC:0:0 /= REDUCTION(FRAC:0:0, FRAC:0:1)
	FRAC:0:1 /= REDUCTION(FRAC:0:0, FRAC:0:1)
	;約分して分母が1になったとき
	IF FRAC:0:1 == 1
		FRAC:0:1 = 0
		RETURNF ARG:0*ARG:1 + FRAC:0:0
	ENDIF
	RETURNF ARG:0 * ARG:1
ELSEIF ARG:2 == 3
	RETURNF ARG:0 - ARG:1
ELSEIF ARG:2 == 4
	IF ARG:1 == 0;0で割らないように
		CALC_ERR = 1
		RETURNF 0
	ELSE
		IF FRAC:0:1 != 0;帯分数を割るとき、仮分数に直し普通の割り算に帰着させる
			ARG:0 = FRAC:0:0 + ARG:0*FRAC:0:1
			ARG:1 *= FRAC:0:1
		ENDIF
		IF ARG:0 % ARG:1 != 0;割り切れないとき、帯分数に
			FRAC:0:0 = ARG:0 - ARG:1*(ARG:0 / ARG:1)
			FRAC:0:1 = ARG:1
		ENDIF
		;ここから約分
		FRAC:0:0 /= REDUCTION(FRAC:0:0, FRAC:0:1)
		FRAC:0:1 /= REDUCTION(FRAC:0:0, FRAC:0:1)
		;元から分数があるとき割り算をしても分数は減らないのでそのまま返す
		RETURNF ARG:0 / ARG:1
	ENDIF
ELSEIF ARG:2 == 5
	IF ARG:1 == 0
		RETURNF 1
	ELSEIF ARG:0 == 0
		RETURNF 0
	ELSEIF ARG:1*(1+LOG10(ABS(ARG:0))) > 16;答えが1京を超えないように
		CALC_ERR = 1
		RETURNF 0
	ELSEIF FRAC:0:1 != 0
		FRAC:0:0 += ARG:0*FRAC:0:1;仮分数に直す
		IF FRAC:0:0 == 0
			RETURNF 0
		ELSEIF ARG:1*(1+LOG10(ABS(FRAC:0:0))) > 16 || ARG:1*(1+LOG10(ABS(FRAC:0:1))) > 16
			CALC_ERR = 0
			RETURNF 0
		ELSE
			FRAC:0:0 = POWER(FRAC:0:0, ARG:1)
			FRAC:0:1 = POWER(FRAC:0:1, ARG:1)
			LOCAL = FRAC:0:0 / FRAC:0:1
			FRAC:0:0 -= LOCAL*FRAC:0:1
			RETURNF LOCAL
		ENDIF
	ELSE
		RETURNF POWER(ARG:0,ARG:1)
	ENDIF
ELSEIF ARG:2 == 6
	IF FRAC:0:1 != 0;帯分数が入っている状態で結合はできない
		CALC_ERR = 1
		RETURNF 0
	ENDIF
	IF ARG:0 == 0 || ARG:1 < 0
		CALC_ERR = 1
		RETURNF 0
	ELSEIF ARG:1 == 0
		RETURNF 10*ARG:0
	ELSE
		RETURNF POWER(10,1+LOG10(ARG:1))*ARG:0+SIGN(ARG:0)*ARG:1
	ENDIF
ELSE
	CALC_ERR = 1
	RETURNF 0
ENDIF


;CALC1は最初の計算でしか使われることはない
;また答えが分数になるときFRAC:1に代入される
@CALC1(ARG:0,ARG:1,ARG:2)
#FUNCTION
IF ARG:2 == 1
	RETURNF ARG:0 + ARG:1
ELSEIF ARG:2 == 2
	RETURNF ARG:0 * ARG:1
ELSEIF ARG:2 == 3
	RETURNF ARG:0 - ARG:1
ELSEIF ARG:2 == 4
	IF ARG:1 == 0;0で割らないように
		CALC_ERR = 1
		RETURNF 0
	ELSE
		IF ARG:0 % ARG:1 != 0;割り切れないとき、帯分数に
			FRAC:1:0 = ARG:0 - ARG:1*(ARG:0/ARG:1)
			FRAC:1:1 = ARG:1
		ENDIF
		FRAC:1:0 /= REDUCTION(FRAC:1:0, FRAC:1:1)
		FRAC:1:1 /= REDUCTION(FRAC:1:0, FRAC:1:1)
		RETURNF ARG:0 / ARG:1
	ENDIF
ELSEIF ARG:2 == 5
	;0^0=1としている
	IF ARG:1 == 0
		RETURNF 1
	;0を0乗以外で0
	ELSEIF ARG:0 == 0
		RETURNF 0
	;答えが1京を超えないように
	ELSEIF ARG:1*(1+LOG10(ABS(ARG:0))) > 16
		CALC_ERR = 1
		RETURNF 0
	ELSE
		RETURNF POWER(ARG:0,ARG:1)
	ENDIF
ELSEIF ARG:2 == 6
	IF ARG:0 == 0 || ARG:1 < 0
		CALC_ERR = 1
		RETURNF 0
	ELSEIF ARG:1 == 0
		RETURNF 10*ARG:0
	ELSE
		RETURNF POWER(10,1+LOG10(ARG:1))*ARG:0+SIGN(ARG:0)*ARG:1
	ENDIF
ELSE
	CALC_ERR = 1
	RETURNF 0
ENDIF


;CALC2に対し帯分数がくるときは必ずARG:1
@CALC2(ARG:0,ARG:1,ARG:2)
#FUNCTION
SIF FRAC:0:1 == 0
	FRAC:0:0 = 0
IF ARG:2 == 1
	RETURNF ARG:0 + ARG:1
ELSEIF ARG:2 == 2
	FRAC:0:0 *= ARG:0
	;ここから約分
	FRAC:0:0 /= REDUCTION(FRAC:0:0, FRAC:0:1)
	FRAC:0:1 /= REDUCTION(FRAC:0:0, FRAC:0:1)
	IF FRAC:0:1 == 1
		FRAC:0:1 = 0
		RETURNF ARG:0*ARG:1 + FRAC:0:0
	ENDIF
	RETURNF ARG:0 * ARG:1
ELSEIF ARG:2 == 3
	FRAC:0:0 *= -1
	RETURNF ARG:0 - ARG:1
ELSEIF ARG:2 == 4
	IF ARG:1 == 0;0で割らないように
		CALC_ERR = 1
		RETURNF 0
	ELSE
		IF FRAC:0:1 != 0;帯分数で割るとき、仮分数に直し普通の割り算に帰着させる
			ARG:0 *= FRAC:0:1
			ARG:1 = FRAC:0:0 + ARG:1*FRAC:0:1
		ENDIF
		IF ARG:1 == 0;0で割らないように
			CALC_ERR = 1
			RETURNF 0
		ENDIF
		IF ARG:0 % ARG:1 != 0;割り切れないとき、帯分数に
			FRAC:0:0 = ARG:0 - ARG:1*(ARG:0/ARG:1)
			FRAC:0:1 = ARG:1
		ENDIF
		;ここから約分
		FRAC:0:0 /= REDUCTION(FRAC:0:0, FRAC:0:1)
		FRAC:0:1 /= REDUCTION(FRAC:0:0, FRAC:0:1)
		IF FRAC:0:1 == 1
			FRAC:0:1 = 0
			RETURNF ARG:0/ARG:1 + FRAC:0:0
		ELSE
			RETURNF ARG:0/ARG:1
		ENDIF
	ENDIF
ELSEIF ARG:2 == 5
	;整数乗でないパターンを最初に計算
	IF FRAC:0:1 != 0
		FRAC:0:0 += ARG:1 * FRAC:0:1;仮分数に直す
		FRAC:0:0 /= REDUCTION(FRAC:0:0, FRAC:0:1)
		FRAC:0:1 /= REDUCTION(FRAC:0:0, FRAC:0:1)
		;LOG10(0)回避
		IF ARG:0 == 0
			IF FRAC:0:0 == 0
				RETURNF 1
			ELSE
				RETURNF 0
			ENDIF
		;負の数の非整数乗はダメ
		;答えが1京より大きいのもダメ
		ELSEIF FRAC:0:0 < 0 || FRAC:0:0*(1+LOG10(ABS(ARG:0)))/FRAC:0:1 > 16
			CALC_ERR = 1
			RETURNF 0
		ELSEIF FRAC:0:1 == 2 && ARG:0 == POWER(SQRT(ABS(ARG:0)), 2);2乗根が計算できるとき
			FRAC:0:1 = 0
			ARG:0 = SQRT(ARG:0)
			RETURNF POWER(ARG:0, FRAC:0:0)
		ELSEIF FRAC:0:1 == 3 && ABS(ARG:0) == POWER(CBRT(ABS(ARG:0)), 3);3乗根が計算できるとき
			FRAC:0:1 = 0
			ARG:0 = SIGN(ARG:0)*CBRT(ABS(ARG:0))
			RETURNF POWER(ARG:0, FRAC:0:0)
		ELSEIF FRAC:0:1 == 4 && ARG:0 == POWER(SQRT(SQRT(ABS(ARG:0))), 4);4乗根が計算できるとき
			FRAC:0:1 = 0
			ARG:0 = SQRT(SQRT(ARG:0))
			RETURNF POWER(ARG:0, FRAC:0:0)
		ENDIF
		;これ以外のパターンは計算不能とする
		CALC_ERR = 1
		RETURNF 0
	ELSEIF ARG:0 == 0
		IF ARG:1 == 0
			RETURNF 1
		ELSE
			RETURNF 0
		ENDIF
	ELSEIF ARG:1*(1+LOG10(ABS(ARG:0))) > 16;答えが1京を超えないように
		CALC_ERR = 1
		RETURNF 0
	ELSE
		RETURNF POWER(ARG:0,ARG:1)
	ENDIF
ELSEIF ARG:2 == 6
	IF FRAC:0:1 != 0;帯分数が入っている状態で結合はできない
		CALC_ERR = 1
		RETURNF 0
	ENDIF
	IF ARG:0 == 0 || ARG:1 < 0
		CALC_ERR = 1
		RETURNF 0
	ELSEIF ARG:1 == 0
		RETURNF 10*ARG:0
	ELSE
		RETURNF POWER(10,1+LOG10(ARG:1))*ARG:0+SIGN(ARG:0)*ARG:1
	ENDIF
ELSE
	CALC_ERR = 1
	RETURNF 0
ENDIF


;CALC3に対しては帯分数はどちらにも入りうる
;また、「分母が異なる既約分数の和は整数にならない」という性質を使う
@CALC3(ARG:0,ARG:1,ARG:2)
#FUNCTION
SIF FRAC:0:1 == 0
	FRAC:0:0 = 0
SIF FRAC:1:1 == 0
	FRAC:1:0 = 0
IF ARG:2 == 1
	;分母が異なるとダメ
	SIF FRAC:0:1 != FRAC:1:1
		CALC_ERR = 1
	;分母は同じだが分子を足し算して分母で割り切れなければダメ
	SIF FRAC:0:1 != 0 && (FRAC:0:0+FRAC:1:0)%FRAC:0:1 != 0
		CALC_ERR = 1
	SIF FRAC:0:1 == 0
		FRAC:0:1 = 1;ゼロ除算対策
	RETURNF ARG:0 + ARG:1 + (FRAC:0:0+FRAC:1:0) / FRAC:0:1
ELSEIF ARG:2 == 2
	;どちらも分数でないとき
	SIF FRAC:0:1 == 0 && FRAC:1:1 == 0
		RETURNF ARG:0 * ARG:1
	IF FRAC:1:1 == 0;FRAC:0は存在する
		FRAC:0:0 *= ARG:1
		SIF FRAC:0:0 % FRAC:0:1 != 0
			CALC_ERR = 1;答えは整数ではない
		RETURNF ARG:0 * ARG:1 + FRAC:0:0/FRAC:0:1
	ELSEIF FRAC:0:1 == 0;FRAC:1は存在する
		FRAC:1:0 *= ARG:0
		SIF FRAC:1:0 % FRAC:1:1 != 0
			CALC_ERR = 1;答えは整数ではない
		RETURNF ARG:0 * ARG:1 + FRAC:1:0/FRAC:1:1
	ELSE ;FRAC:0とFRAC:1は存在する
		;全て仮分数に直す
		FRAC:0:0 += FRAC:0:1 * ARG:0
		FRAC:1:0 += FRAC:1:1 * ARG:1
		SIF (FRAC:0:0 * FRAC:1:0) % (FRAC:0:1 * FRAC:1:1) != 0
			CALC_ERR = 1
		RETURNF (FRAC:0:0 * FRAC:1:0) / (FRAC:0:1 * FRAC:1:1)
	ENDIF
ELSEIF ARG:2 == 3
	;分母が異なるとダメ
	SIF FRAC:0:1 != FRAC:1:1
		CALC_ERR = 1
	;分母は同じだが分子を足し算して分母で割り切れなければダメ
	SIF FRAC:0:1 != 0 && (FRAC:0:0-FRAC:1:0)%FRAC:0:1 != 0
		CALC_ERR = 1
	SIF FRAC:0:1 == 0
		FRAC:0:1 = 1;ゼロ除算対策
	RETURNF ARG:0 - ARG:1 + (FRAC:0:0-FRAC:1:0) / FRAC:0:1
ELSEIF ARG:2 == 4
	IF ARG:1 == 0;0で割らないように
		CALC_ERR = 1
		RETURNF 0
	ELSE
		;全て仮分数に直す
		IF FRAC:0:1 == 0
			FRAC:0:0 = ARG:0
			FRAC:0:1 = 1
		ELSE
			FRAC:0:0 += FRAC:0:1 * ARG:0
		ENDIF
		IF FRAC:1:1 == 0
			FRAC:1:0 = ARG:1
			FRAC:1:1 = 1
		ELSE
			FRAC:1:0 += FRAC:1:1 * ARG:1
		ENDIF
		SIF (FRAC:0:0 * FRAC:1:1) % (FRAC:0:1 * FRAC:1:0) != 0
			CALC_ERR = 1
		RETURNF (FRAC:0:0 * FRAC:1:1) / (FRAC:0:1 * FRAC:1:0)
	ENDIF
ELSEIF ARG:2 == 5
	;既約分数を有理数乗しても整数にならないのでダメ
	IF FRAC:0:1 != 0
		CALC_ERR = 1
		RETURNF 0
	;整数の非整数乗
	ELSEIF FRAC:1:1 != 0
		FRAC:1:0 += ARG:1 * FRAC:1:1;仮分数に直す
		FRAC:1:0 /= REDUCTION(FRAC:1:0, FRAC:1:1)
		FRAC:1:1 /= REDUCTION(FRAC:1:0, FRAC:1:1)
		;LOG10(0)回避
		IF ARG:0 == 0
			IF FRAC:1:1 == 0
				RETURNF 1
			ELSE
				RETURNF 0
			ENDIF
		;負の数の非整数乗はダメ
		;答えが1京より大きいのもダメ
		ELSEIF FRAC:1:0 < 0 || FRAC:1:0*(1+LOG10(ABS(ARG:0)))/FRAC:1:1 > 16
			CALC_ERR = 1
			RETURNF 0
		ELSEIF FRAC:1:1 == 2 && ARG:0 == POWER(SQRT(ABS(ARG:0)), 2);2乗根が計算できるとき
			FRAC:1:1 = 0
			ARG:0 = SQRT(ARG:0)
			RETURNF POWER(ARG:0, FRAC:1:0)
		ELSEIF FRAC:1:1 == 3 && ABS(ARG:0) == POWER(CBRT(ABS(ARG:0)), 3);3乗根が計算できるとき
			FRAC:1:1 = 0
			ARG:0 = SIGN(ARG:0)*CBRT(ABS(ARG:0))
			RETURNF POWER(ARG:0, FRAC:1:0)
		ELSEIF FRAC:1:1 == 4 && ARG:0 == POWER(SQRT(SQRT(ABS(ARG:0))), 4);4乗根が計算できるとき
			FRAC:1:1 = 0
			ARG:0 = SQRT(SQRT(ARG:0))
			RETURNF POWER(ARG:0, FRAC:1:0)
		ENDIF
		;これ以外のパターンは計算不能とする
		CALC_ERR = 1
		RETURNF 0
	;残りは全部整数同士
	ELSEIF ARG:0 == 0
		IF ARG:1 == 0
			RETURNF 1
		ELSE
			RETURNF 0
		ENDIF
	ELSEIF ARG:1*(1+LOG10(ABS(ARG:0))) > 16;答えが1京を超えないように
		CALC_ERR = 1
		RETURNF 0
	ELSE
		RETURNF POWER(ARG:0,ARG:1)
	ENDIF
ELSEIF ARG:2 == 6
	IF FRAC:0:1 != 0 || FRAC:1:1 != 0;帯分数が入っている状態で結合はできない
		CALC_ERR = 1
		RETURNF 0
	ENDIF
	IF ARG:0 == 0 || ARG:1 < 0
		CALC_ERR = 1
		RETURNF 0
	ELSEIF ARG:1 == 0
		RETURNF 10*ARG:0
	ELSE
		RETURNF POWER(10,1+LOG10(ARG:1))*ARG:0+SIGN(ARG:0)*ARG:1
	ENDIF
ELSE
	CALC_ERR = 1
	RETURNF 0
ENDIF


;約分用の関数
;GCDと違ってどちらかが0なら特例で1を返す
@REDUCTION(ARG, ARG:1)
#FUNCTION
#DIM DYNAMIC L_GCD
L_GCD = GCD(ARG, ARG:1)
IF L_GCD
	RETURNF L_GCD
ELSE
	RETURNF 1
ENDIF


;Greatest Common Divisor(最大公約数)を求める
;ユークリッドの互除法を使用
;ただしどちらかが0のとき特例で0を返すので注意
@GCD(ARG, ARG:1)
#FUNCTION
#DIM DYNAMIC INT_L;大きい方
#DIM DYNAMIC INT_S;小さい方
#DIM DYNAMIC INT_R;余り

SIF ARG*ARG:1==0
	RETURNF 0

INT_L = ABS(ARG)
INT_S = ABS(ARG:1)
SIF INT_L < INT_S
	SWAP INT_L, INT_S

DO
	SIF INT_S == 0
		RETURNF INT_L
	INT_R = INT_L % INT_S
	INT_L = INT_S
	INT_S = INT_R
LOOP 1
