;絶対値が2^63未満の整数を2つ使って絶対値が2^126未満の整数を表します
;ここで整数2つでワンセットの形式をDOUBLEと呼ばせてください
;一般的な倍精度浮動小数点数(Double型)とは異なります


@CHKOVF(ARG, ARG:1)
;|ARG+ARG:1|>=2^63かどうかをチェックする
;2^63以上なら1、-2^63以下なら-1、それ以外なら0を返す
#FUNCTION
#DIM DYNAMIC N62A
#DIM DYNAMIC N62B

SELECTCASE SIGN(ARG)*SIGN(ARG:1)
	CASE 1
		SELECTCASE GETBIT(ABS(ARG),62)+GETBIT(ABS(ARG:1),62)
			CASE 2
				RETURNF SIGN(ARG)
			CASE 1
				N62A = ABS(ARG) - GETBIT(ABS(ARG),62)*POWER(2,62)
				N62B = ABS(ARG:1) - GETBIT(ABS(ARG:1),62)*POWER(2,62)
				IF N62A+N62B >= POWER(2,62)
					RETURNF SIGN(ARG)
				ELSE
					RETURNF 0
				ENDIF
			CASE 0
				RETURNF 0
		ENDSELECT
	CASEELSE
		RETURNF 0
ENDSELECT


@D_PLUS(ARG=0, ARG:1=0, ARG:2=0, ARG:3=0)
;{ARG*2^63+ARG:1}+{ARG:2*2^63+ARG:3}を計算する
;答えは[ANS63]*2^63+[ANS0]となる
;返り値の3つ目で絶対値が2^126を超えたかどうかを示す
;1で2^126以上、-1で-2^126以下、0でそれ以外
;2^62 = 4611686018427387904
;2^63 = 9223372036854775808
#DIM DYNAMIC ANS0
#DIM DYNAMIC ANS63
#DIM DYNAMIC INTO63
#DIM DYNAMIC XARG
#DIM CONST LIM = 9223372036854775807

SELECTCASE CHKOVF(ARG:1, ARG:3)
	CASE 1
		INTO63 = 1
		ANS0 = ARG:1
		ANS0 -= 1p62
		ANS0 += ARG:3
		ANS0 -= 1p62
	CASE -1
		INTO63 = -1
		ANS0 = ARG:1
		ANS0 += 1p62
		ANS0 += ARG:3
		ANS0 += 1p62
	CASE 0
		ANS0 = ARG:1 + ARG:3
ENDSELECT

;オーバーフローをしていない繰り上がり繰り下がりの処理
;値を破壊しないようにARGをXARGに入れておく
XARG = ARG
;ANS0がマイナスなのに、ANS63がプラスになるのなら繰り下がりを行う
IF ANS0 < 0
	SELECTCASE SIGN(ARG)*SIGN(ARG:2)
		CASE 1
			;同符号
			IF ARG > 0
				XARG -= 1
				ANS0 += 1p62
				ANS0 += 1p62
			ENDIF
		CASEELSE
			;異符号もしくは少なくとも1つが0
			IF ARG+ARG:2 > 1
				XARG -= 1
				ANS0 += 1p62
				ANS0 += 1p62
			ELSEIF ARG+ARG:2 == 1 && INTO63 == 0
				XARG -= 1
				ANS0 += 1p62
				ANS0 += 1p62
			ENDIF
	ENDSELECT
;ANS0がプラスなのに、ANS63がマイナスになるのなら繰り上がりを行う
ELSEIF ANS0 > 0
	SELECTCASE SIGN(ARG)*SIGN(ARG:2)
		CASE 1
			;同符号
			IF ARG < 0
				XARG += 1
				ANS0 -= 1p62
				ANS0 -= 1p62
			ENDIF
		CASEELSE
			;異符号もしくは少なくとも1つが0
			IF ARG+ARG:2 < -1
				XARG += 1
				ANS0 -= 1p62
				ANS0 -= 1p62
			ELSEIF ARG+ARG:2 == -1 && INTO63 == 0
				XARG += 1
				ANS0 -= 1p62
				ANS0 -= 1p62
			ENDIF
	ENDSELECT
ENDIF

SELECTCASE CHKOVF(XARG, ARG:2)
	CASE 1
		RETURN LIM, LIM, 1
	CASE -1
		RETURN -LIM, -LIM, -1
	CASE 0
		IF XARG+ARG:2 == LIM && INTO63 == 1
			RETURN LIM, LIM, 1
		ELSEIF XARG+ARG:2 == -LIM && INTO63 == -1
			RETURN -LIM, -LIM, -1
		ELSE
			ANS63 = XARG + ARG:2 + INTO63
			RETURN ANS63, ANS0, 0
		ENDIF
ENDSELECT


@D_NORM(ARG, ARG:1)
#DIM ANS, 2
;ARG*2^63+ARG:1を想定したとき、ARGとARG:1が異符号であるものを同符号に直す
;それをここでは便宜上「正規化」と呼ぶことにする
IF SIGN(ARG)*SIGN(ARG:1) == -1
	IF ARG > 0
		ANS = ARG - 1
		ANS:1 = ARG:1 - 1p62
		ANS:1 -= 1p62
	ELSE
		ANS = ARG + 1
		ANS:1 = ARG:1 + 1p62
		ANS:1 += 1p62
	ENDIF
ELSE
	ANS = ARG
	ANS:1 = ARG:1
ENDIF
RETURN ANS, ANS:1


@D_MULTI(ARG=0, ARG:1=0, ARG:2=0)
;{ARG}*{ARG:1*2^63+ARG:2}を計算する
;答えは[ANS63]*2^63+[ANS0]となる
;返り値の3つ目で絶対値が2^126を超えたかどうかを示す
;1で2^126以上、-1で-2^126以下、0でそれ以外
;二進数での掛け算(63桁×126桁)の筆算をイメージ
#DIM DYNAMIC ANS0
#DIM DYNAMIC ANS63
#DIM DYNAMIC XARG, 3
#DIM DYNAMIC ANSIGN
#DIM DYNAMIC LCL, 126
#DIM DYNAMIC SUBT, 127
#DIM DYNAMIC LCOUNT, 2
#DIM DYNAMIC CARRY
#DIM CONST LIM = 9223372036854775807

XARG = ARG

CALL D_NORM(ARG:1, ARG:2)
ANSIGN = SIGN(SIGN(RESULT)+SIGN(RESULT:1))*SIGN(XARG)
XARG:1 = ABS(RESULT)
XARG:2 = ABS(RESULT:1)

FOR LCOUNT, 0, 63
	SIF GETBIT(XARG:1,LCOUNT)
		LCL:LCOUNT = XARG
NEXT
FOR LCOUNT, 0, 63
	SIF GETBIT(XARG:2,LCOUNT)
		LCL:(LCOUNT+1) = XARG
NEXT

FOR LCOUNT, 0, 63
	FOR LCOUNT:1, 0, LCOUNT+1
		SUBT:LCOUNT += GETBIT(LCL:(LCOUNT:1), LCOUNT-LCOUNT:1)
	NEXT
NEXT
FOR LCOUNT, 0, 63
	FOR LCOUNT:1, 0, 63
		SUBT:(63+LCOUNT) += GETBIT(LCL:(1+LCOUNT+LCOUNT:1), 62-LCOUNT:1)
	NEXT
NEXT

FOR LCOUNT, 0, 62
	SUBT:126 += GETBIT(LCL:(64+LCOUNT), 62-LCOUNT)
NEXT

FOR LCOUNT, 0, 63
	SUBT:LCOUNT += CARRY
	SIF SUBT:LCOUNT%2
		SETBIT ANS0, LCOUNT
	CARRY = SUBT:LCOUNT/2
NEXT
FOR LCOUNT, 0, 63
	SUBT:(63+LCOUNT) += CARRY
	SIF SUBT:(63+LCOUNT)%2
		SETBIT ANS63, LCOUNT
	CARRY = SUBT:LCOUNT/2
NEXT
SUBT:126 += CARRY

IF SUBT:126 > 0
	RETURN ANSIGN*LIM, ANSIGN*LIM, ANSIGN
ELSE
	RETURN ANSIGN*ANS63, ANSIGN*ANS0, 0
ENDIF


@DEC2D(ARGS)
;文字列として入力された十進数の"数値"を「[ANS63]*2^63+[ANS0]」に直す
#DIM DYNAMIC OVF
#DIM DYNAMIC E0
#DIM DYNAMIC E15
#DIM DYNAMIC E30
#DIM DYNAMIC ANS0
#DIM DYNAMIC ANS63
#DIM DYNAMIC ANSIGN
#DIM DYNAMIC DIGIT
#DIM DYNAMIC LCL, 2
#DIM CONST E30TOB, 2 = 108420217248, 5076944270305263616
#DIM CONST LIM = 9223372036854775807
#DIMS DYNAMIC LSTR

ARGS="3"
IF CHARATU(ARGS, 0) == "-"
	ANSIGN = -1
	LSTR = %SUBSTRING(ARGS, 1)%
ELSE
	ANSIGN = 1
	LSTR = ARGS
ENDIF

DIGIT = STRLENS(LSTR)
IF DIGIT > 30
	E30 = TOINT(SUBSTRING(LSTR, 0, DIGIT-30))
	E15 = TOINT(SUBSTRING(LSTR, DIGIT-30, 15))
	 E0 = TOINT(SUBSTRING(LSTR, DIGIT-15, 15))
ELSEIF DIGIT > 15
	E15 = TOINT(SUBSTRING(LSTR, 0, DIGIT-15))
	 E0 = TOINT(SUBSTRING(LSTR, DIGIT-15, 15))
ELSE
	 E0 = TOINT(LSTR)
ENDIF
ANS0 = E0

IF E15
	CALL D_MULTI, 1e15, 0, E15
	LCL:0 = RESULT
	LCL:1 = RESULT:1
	CALL D_PLUS, 0, ANS0, LCL:0, LCL:1
	ANS63 = RESULT
	ANS0 = RESULT:1
ENDIF

IF E30
	CALL D_MULTI, E30, E30TOB:0, E30TOB:1
	LCL:0 = RESULT
	LCL:1 = RESULT:1
	OVF = RESULT:2
	SIF OVF
		RETURN OVF*LIM, OVF*LIM, OVF
	CALL D_PLUS, ANS63, ANS0, LCL:0, LCL:1
	ANS63 = RESULT
	ANS0 = RESULT:1
	OVF = RESULT:2
	SIF OVF
		RETURN OVF*LIM, OVF*LIM, OVF
ENDIF

RETURN ANSIGN*ANS63, ANSIGN*ANS0, 0


@D2DEC(ARG, ARG:1)
;「ARG*2^63+ARG:1」を「[ANS36]*10^36+[ANS24]*10^24+[ANS12]*10^12+[ANS0]」に直す
;10^12ごとに区切ったのは、10^4ごとに区切る漢字文化圏の命数法と10^3ごとに区切る西洋の命数法の両方で使いやすくするためである
;10^12……1兆, 1 trillion, 1T(テラ)
;10^24……1𥝱, 1 septillion, 1Y(ヨタ)
;10^36……1澗, 1 undecillion, 1U(ウダ ※Jim Blowersによる私案)
#DIM ANS36, 126
#DIM ANS24, 126
#DIM ANS12, 126
#DIM ANS0, 126
#DIM MAKE2P
#DIM DYNAMIC ANS36T
#DIM DYNAMIC ANS24T
#DIM DYNAMIC ANS12T
#DIM DYNAMIC ANS0T
#DIM DYNAMIC XARG, 2
#DIM DYNAMIC LBIT
#DIM DYNAMIC ANSIGN

CALL D_NORM(ARG, ARG:1)
ANSIGN = SIGN(SIGN(RESULT)+SIGN(RESULT:1))
XARG = ABS(RESULT)
XARG:1 = ABS(RESULT:1)

IF !MAKE2P
	ANS0:0 = 1
	FOR LBIT, 1, 126
		ANS0:LBIT *= 2
		ANS12:LBIT *= 2
		ANS24:LBIT *= 2
		ANS36:LBIT *= 2
		IF ANS0:LBIT >= 1e12
			ANS12++
			ANS0 -= 1e12
		ENDIF
		IF ANS12:LBIT >= 1e12
			ANS24++
			ANS12 -= 1e12
		ENDIF
		IF ANS24:LBIT >= 1e12
			ANS36++
			ANS24 -= 1e12
		ENDIF
	NEXT
	MAKE2P = 1
ENDIF

FOR LBIT, 0, 63
	IF GETBIT(XARG:1, LBIT)
		ANS0T += ANS0:LBIT
		ANS12T += ANS12:LBIT
		ANS24T += ANS24:LBIT
		ANS36T += ANS36:LBIT
	ENDIF
NEXT
FOR LBIT, 63, 126
	IF GETBIT(XARG, LBIT-63)
		ANS0T += ANS0:LBIT
		ANS12T += ANS12:LBIT
		ANS24T += ANS24:LBIT
		ANS36T += ANS36:LBIT
	ENDIF
NEXT

ANS12T += ANS0T/1e12
ANS0T %= 1e12
ANS24T += ANS12T/1e12
ANS12T %= 1e12
ANS36T += ANS24T/1e12
ANS24T %= 1e12

RETURN ANSIGN, ANS36T, ANS24T, ANS12T, ANS0T


;以下の関数は上記で作った12桁ごとに区切られた数を表すための関数
@DLOG10(ARG, ARG:1, ARG:2, ARG:3)
;要するに十進数での桁数-1
;桁数を数える用途なのでDLOG10(0)にも0を返す
;なお2^126-1は38桁、ここでは37を返す
#FUNCTION
#DIM DYNAMIC NONZERO
#DIM DYNAMIC LCL

IF ARG > 0
	NONZERO = 0
ELSEIF ARG:1 > 0
	NONZERO = 1
ELSEIF ARG:2 > 0
	NONZERO = 2
ELSE
	NONZERO = 3
ENDIF

IF ARG:(NONZERO) <= 0
	LCL = 0
ELSE
	LCL = LOG10(ARG:(NONZERO))
ENDIF

LCL += 12*(3-NONZERO)

RETURNF LCL


@D2STR(ARG, ARG:1, ARG:2, ARG:3)
;1本の文字列にする関数
#FUNCTIONS
#DIM DYNAMIC LCOUNT
#DIM DYNAMIC DIGIT
#DIMS DYNAMIC LSTR

DIGIT = 1+DLOG10(ARG, ARG:1, ARG:2, ARG:3)
IF DIGIT > 36
	LSTR += TOSTR(ARG)
	FOR LCOUNT, 0, 12-STRLENS(TOSTR(ARG:1))
		LSTR += "0"
	NEXT
ENDIF
IF DIGIT > 24
	LSTR += TOSTR(ARG:1)
	FOR LCOUNT, 0, 12-STRLENS(TOSTR(ARG:2))
		LSTR += "0"
	NEXT
ENDIF
IF DIGIT > 12
	LSTR += TOSTR(ARG:2)
	FOR LCOUNT, 0, 12-STRLENS(TOSTR(ARG:3))
		LSTR += "0"
	NEXT
ENDIF
LSTR += TOSTR(ARG:3)

RETURNF LSTR


@PRTD(ARG, ARG:1)
CALL D2DEC(ARG, ARG:1)
LOCALS = 
SIF RESULT < 0
	LOCALS = "-"
LOCALS += D2STR(RESULT:1, RESULT:2, RESULT:3, RESULT:4)
PRINTFORM %LOCALS%


@D2SI(ARG, ARG:1, ARG:2, ARG:3)
;右詰めで「半角5文字+SI接頭辞」で数値を表す
#FUNCTIONS
#DIM DYNAMIC DIGIT
#DIM DYNAMIC LCOUNT
#DIMS DYNAMIC LSTR
#DIMS DYNAMIC MSTR

LSTR = %D2STR(ARG, ARG:1, ARG:2, ARG:3)%
DIGIT = STRLENS(LSTR)

IF DIGIT <= 6
	FOR LCOUNT, 0, 6-DIGIT
		MSTR += " "
	NEXT
	MSTR += LSTR
ELSEIF DIGIT >= 7
	SELECTCASE DIGIT%3
		CASE 0
			MSTR += SUBSTRING(LSTR, 0, 3)
			MSTR += "."
			MSTR += CHARATU(LSTR, 3)
		CASE 1
			MSTR += " "
			MSTR += SUBSTRING(LSTR, 0, 4)
		CASE 2
			MSTR += SUBSTRING(LSTR, 0, 5)
	ENDSELECT
	SELECTCASE DIGIT
		CASE 7, 8
			MSTR += "k"
		CASE 9 TO 11
			MSTR += "M"
		CASE 12 TO 14
			MSTR += "G"
		CASE 15 TO 17
			MSTR += "T"
		CASE 18 TO 20
			MSTR += "P"
		CASE 21 TO 23
			MSTR += "E"
		CASE 24 TO 26
			MSTR += "Z"
		CASE 27 TO 29
			MSTR += "Y"
		CASE 30 TO 32
			MSTR += "X"
		CASE 33 TO 35
			MSTR += "W"
		CASE 36 TO 38
			MSTR += "V"
	ENDSELECT
ENDIF

RETURNF MSTR


@D2EN(ARG, ARG:1, ARG:2, ARG:3, MDIGIT, TYPE=-1, ZERO=0)
;指数表記(exponential notation) A*10^N (0<A<10, Nは整数) で表す関数
;MDIGITで仮数部(mantissa)Aの小数点以下の桁数を指定する
;TYPEは表示できる仮数部の一番下の位をどう扱うか
;	-1……切り捨て, 0……四捨五入, 1……切り上げ
;ZEROは指数部分が1桁のときに"0"で埋めるか
;0以外を入力していると埋める (例:1.7e04)
#FUNCTIONS
#DIM DYNAMIC MDIGIT
#DIM DYNAMIC TYPE
#DIM DYNAMIC ZERO
#DIM DYNAMIC LCOUNT
#DIM DYNAMIC LCL
#DIMS DYNAMIC LSTR
#DIMS DYNAMIC MSTR

LSTR = %D2STR(ARG, ARG:1, ARG:2, ARG:3)%

IF TYPE == 0
	SIF TOINT(CHARATU(LSTR, 1+MDIGIT)) >= 5
		GOTO ROUNDUP
ELSEIF TYPE > 0
	IF TOINT(SUBSTRING(LSTR, 1+MDIGIT))
		$ROUNDUP
		FOR LCOUNT, MDIGIT, -1, -1
			LCL = TOINT(CHARATU(LSTR, LCOUNT))
			IF LCL == 9
				LSTR = %SUBSTRING(LSTR, 0, LCOUNT)%0%SUBSTRING(LSTR, LCOUNT+1)%
				SIF LCOUNT == 0
					LSTR = 1%LSTR%
			ELSE
				LSTR = %SUBSTRING(LSTR, 0, LCOUNT)%%TOSTR(LCL+1)%%SUBSTRING(LSTR, LCOUNT+1)%
				BREAK
			ENDIF
		NEXT
	ENDIF
ENDIF

MSTR += CHARATU(LSTR, 0)
IF MDIGIT > 0
	MSTR += "."
	MSTR += SUBSTRING(LSTR, 1, MDIGIT)
	IF STRLENS(LSTR)-1 < MDIGIT
		FOR LCOUNT, 0, 1+MDIGIT-STRLENS(LSTR)
			MSTR += "0"
		NEXT
	ENDIF
ENDIF

MSTR += "e"
SIF STRLENS(LSTR)-1 <= 9 && ZERO
	MSTR += "0"

MSTR += TOSTR(STRLENS(LSTR)-1)

RETURNF MSTR
